[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\nPseudobulk and related approaches for scRNA-seq analysis\n\n\n\nAudience\nComputational skills required\nDuration\n\n\n\n\nBiologists\nIntroduction to R\n3-session online workshop (~7.5 hours of trainer-led time)\n\n\n\n\nDescription\nThis repository has teaching materials for a hands-on workshop on Pseudobulk and related approaches for scRNA-seq analysis. After clustering cells as part of a single-cell RNA-seq experiment, investigators are often interested in carrying out a differential expression analysis between conditions within certain cell types. When the experimental design includes replicates with multiple conditions there is power in identifying differentially expressed genes using a pseudobulk approach. This workshop will:\n\nDiscuss various approaches for differential expression using single cell RNA-seq data\nPrepare single-cell RNA-seq raw count data for pseudobulk analysis\nPerform differential expression analysis on pseudobulk counts using DESeq2\nPresent approaches for evaluating differential proportions of cells between conditions\n\nWorking knowledge of R is required or completion of the Introduction to R workshop.\n\n\n\nNote for Trainers:\nPlease note that the schedule linked below assumes that learners will spend between 3-4 hours on reading through, and completing exercises from selected lessons between classes. The online component of the workshop focuses on more exercises and discussion/Q & A.\n\n\n\n\n\n\n\nNote\n\n\n\nThese materials were developed for a trainer-led workshop, but are also amenable to self-guided learning.\n\n\n\nLearning Objectives\n\nUnderstanding considerations for when to use different DGE algorithms on scRNA-seq data\nUsing FindMarkers to evaluate significantly DE genes\nAggregating single cell expression data into a pseudobulk counts matrix to run a DESeq2 workflow\nEvaluating expression patterns of differentially expressed genes at the pseudobulk and single cell level\nApplication of methods for evaluating differential proportions of cells between conditions\n\n\n\nLessons\n\nWorkshop schedule (trainer-led learning)\nSelf-learning\n\n\n\nInstallation Requirements\n\nApplications\nDownload the most recent versions of R and RStudio for your laptop:\n\nR (version 4.0.0 or above)\nRStudio\n\n\n\nPackages for R\n\nNote 1: Install the packages in the order listed below.\n\n\nNote 2:  All the package names listed below are case sensitive!\n\n\nNote 3: If you have a Mac, download and install this tool before intalling your packages: https://mac.r-project.org/tools/gfortran-12.2-universal.pkg\n\n\nNote 4: At any point (especially if you’ve used R/Bioconductor in the past), in the console R may ask you if you want to update any old packages by asking Update all/some/none? [a/s/n]:. If you see this, type “a” at the prompt and hit Enter to update any old packages. Updating packages can sometimes take quite a bit of time to run, so please account for that before you start with these installations.\n\n\nNote 5: If you see a message in your console along the lines of “binary version available but the source version is later”, followed by a question, “Do you want to install from sources the package which needs compilation? y/n”, type n for no, and hit enter.\n\n(1) Install the 8 packages listed below from Bioconductor using the the BiocManager::install() function.\n\nBiocManager::install(\"DESeq2\")\nBiocManager::install(\"EnhancedVolcano\")\nBiocManager::install(\"SingleCellExperiment\")\nBiocManager::install(\"miloR\")\nBiocManager::install(\"clusterProfiler\")\nBiocManager::install(\"org.Mm.eg.db\")\nBiocManager::install(\"sccomp\")\nBiocManager::install(\"speckle\")\n\nPlease install them one-by-one as follows:\n\nBiocManager::install(\"DESeq2\")\nBiocManager::install(\"EnhancedVolcano\")\n& so on ...\n\n(2) Install the 9 packages listed below from CRAN using the install.packages() function.\n\ninstall.packages(\"Seurat\")\ninstall.packages(\"tidyverse\")\ninstall.packages(\"pheatmap\")\ninstall.packages(\"RColorBrewer\")\ninstall.packages(\"cowplot\")\ninstall.packages(\"dplyr\")\ninstall.packages(\"ggalluvial\")\ninstall.packages(\"msigdbr\")\ninstall.packages(\"ggvenn\")\n\nPlease install them one-by-one as follows:\n\ninstall.packages(\"Seurat\")\ninstall.packages(\"tidyverse\")\ninstall.packages(\"pheatmap\")\n& so on ...\n\n(3) Finally, please check that all the packages were installed successfully by loading them one at a time using the library() function.\n\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(pheatmap)\nlibrary(RColorBrewer)\nlibrary(cowplot)\nlibrary(dplyr)\nlibrary(DESeq2)\nlibrary(EnhancedVolcano)\nlibrary(SingleCellExperiment)\nlibrary(miloR)\nlibrary(ggalluvial)\nlibrary(clusterProfiler)\nlibrary(org.Mm.eg.db)\nlibrary(msigdbr)\nlibrary(ggvenn)\nlibrary(sccomp)\nlibrary(speckle)\n\n(4) Once all packages have been loaded, run sessionInfo().\n\nsessionInfo()"
  },
  {
    "objectID": "lessons/04_pseudobulk_DE_analysis.html",
    "href": "lessons/04_pseudobulk_DE_analysis.html",
    "title": "Pseudobulk DESeq2 analysis",
    "section": "",
    "text": "Approximate time: 40 minutes"
  },
  {
    "objectID": "lessons/04_pseudobulk_DE_analysis.html#learning-objectives",
    "href": "lessons/04_pseudobulk_DE_analysis.html#learning-objectives",
    "title": "Pseudobulk DESeq2 analysis",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nApply methods for sample-level QC\nExplain the different steps involved in running DESeq()\nGenerating a table of differentially expressed genes"
  },
  {
    "objectID": "lessons/04_pseudobulk_DE_analysis.html#sample-level-qc",
    "href": "lessons/04_pseudobulk_DE_analysis.html#sample-level-qc",
    "title": "Pseudobulk DESeq2 analysis",
    "section": "Sample-level QC",
    "text": "Sample-level QC\nA useful initial step in an RNA-seq analysis is to assess overall similarity between samples:\n\nWhich samples are similar to each other? Which are different?\nDoes this fit the expectation from the experiment’s design?\nWhat are the major sources of variation in the dataset?\n\nTo explore the similarity of our samples, we will be performing quality checks using Principal Component Analysis (PCA) and a hierarchical clustering approach.\n\n\n\nSample-level QC allows us to see how well our replicates cluster together, and observe whether the experimental condition represents the major source of variation in the data. Performing sample-level QC can also help identify any sample outliers, which may need to be explored further to determine whether they need to be removed prior to DE analysis.\nIn this lesson, we will introduce to you two different unsupervised clustering methods for exploratory data analysis. When using unsupervised methods it is helpful to apply a normalization or transformation to the data to improve the distances/clustering for visualization, rather than using raw counts. DESeq2 uses median of ratios method for count normalization, which is typically used for plotting expression data downstream after DE analysis. DESeq2 also has the option to transform counts using a regularized log transform (rlog) or varaince stabilizing transform (vst) as these can moderate the variance across the mean, and improve the clustering. The transformation of raw count data is recommended for sample-level QC.\n\nPCA\nPrincipal Component Analysis (PCA) is a dimensionality reduction technique used to emphasize variation and bring out strong patterns in a dataset. Details regarding PCA are given in our prepared lesson linked here.\nWe can run the rlog() function from DESeq2 to normalize and rlog transform the raw counts. Then, we could use the plotPCA() function to plot the first two principal components. By default, the plotPCA() function uses the top 500 most variable genes to compute principal components, but this parameter can be adjusted. Unfortunately, the plotPCA() function doesn’t label the point, so we will use the returnData = TRUE option to create a dataframe that we can use to plot the PCA ourselves.\n\n# Transform counts for data visualization\nrld &lt;- rlog(dds, blind=TRUE)\n\n# Return PCA data as a dataframe\npca_data_condition &lt;- plotPCA(rld, intgroup=c(\"condition\"), returnData = TRUE) \n# Create a new column with the names cleaned up called names_parsed\npca_data_condition &lt;- pca_data_condition %&gt;% \n  mutate(name_parsed = gsub(\"VSM_|_TN|_cold7\", \"\", name))\n\n# Plot the PCA results\nggplot(pca_data_condition, aes(x = PC1, y = PC2, color = condition, label = name_parsed)) +\n  geom_point() + \n  geom_text_repel(vjust = 1.5, hjust = 0.5, show.legend = FALSE) +\n  theme_classic() +\n  xlab(paste0(\"PC1: \", round(attr(pca_data_condition, \"percentVar\")[1] * 100), \"% variance\")) +\n  ylab(paste0(\"PC2: \", round(attr(pca_data_condition, \"percentVar\")[2] * 100), \"% variance\")) \n\n\n\n\nIn this example, we see a nice separation between our samples on PC1 by our condition of interest. This suggests that our condition of interest is the largest source of variation in our dataset. There is also a reasonable amount of within group variation for both TN and cold7 samples, with one of the cold7 samples off on its own in the top right quadrant of the plot.\nWe can check whether the number of cells from which the aggregated counts were derived influences the separation of the samples in the PCA plot. This is particularly useful if you notice an outlier sample, which may be explained by its very low (or very large) cell count compared to others. Here, the number of cells does not appear to explain the outlier cold7 sample.\n\n# Return PCA data as a dataframe\npca_data_n_cells &lt;- plotPCA(rld, intgroup=c(\"n_cells\"), returnData = TRUE) \n# Create a new column with the names cleaned up called names_parsed\npca_data_n_cells &lt;- pca_data_n_cells %&gt;% \n  mutate(name_parsed = gsub(\"VSM_|_TN|_cold7\", \"\", name))\n\n# Plot the PCA results\nggplot(pca_data_n_cells, aes(x = PC1, y = PC2, color = n_cells, label = name_parsed)) +\n  geom_point() + \n  geom_text_repel(vjust = 1.5, hjust = 0.5, show.legend = FALSE) +\n  theme_classic() +\n  xlab(paste0(\"PC1: \", round(attr(pca_data_n_cells, \"percentVar\")[1] * 100), \"% variance\")) +\n  ylab(paste0(\"PC2: \", round(attr(pca_data_n_cells, \"percentVar\")[2] * 100), \"% variance\")) \n\n\n\n\n\n\nSample correlation\nSimilar to PCA, hierarchical clustering is another, complementary method for identifying strong patterns in a dataset and potential outliers. The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination.\nThe hierarchical tree can indicate which samples are more similar to each other based on the normalized gene expression values. The color blocks indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Additionally, we expect to see samples clustered similar to the groupings observed in a PCA plot.\n\n# Calculate sample correlation\nrld_mat &lt;- assay(rld)\nrld_cor &lt;- cor(rld_mat)\n\n# Change sample names to original values\n# For nicer plots\nrename_samples &lt;- bulk_vsm$sample\ncolnames(rld_cor) &lt;- str_replace_all(colnames(rld_cor), rename_samples)\nrownames(rld_cor) &lt;- str_replace_all(rownames(rld_cor), rename_samples)\n\n# Plot heatmap\nanno &lt;- bulk_vsm@meta.data %&gt;%\n            select(sample, condition) %&gt;% \n            remove_rownames() %&gt;% \n            column_to_rownames(\"sample\")\npheatmap(rld_cor, annotation_col=anno, annotation_row=anno)\n\n\n\n\nSince we detected no outliers by PCA or hierarchical clustering, nor do we have any additional sources of variation to regress, we can proceed with running the differential expression analysis.\n\n\n\n\n\n\nExercises\n\n\n\n\nUse the dds_APC object to compute the rlog transformed counts for the Pdgfr α+ APCs.\nCreate a PCA plot for the Pdgfr α+ APCs, coloring points by condition. Do samples segregate by condition? Is there more or less variability within group than observed with the VSM cells?\nEvaluate the sample similarity using a correlation heatmap. How does this compare with the trends observed in the PCA plot?"
  },
  {
    "objectID": "lessons/04_pseudobulk_DE_analysis.html#running-deseq2",
    "href": "lessons/04_pseudobulk_DE_analysis.html#running-deseq2",
    "title": "Pseudobulk DESeq2 analysis",
    "section": "Running DESeq2",
    "text": "Running DESeq2\nDifferential expression analysis with DESeq2 involves multiple steps as displayed in the flowchart below in blue. Briefly, DESeq2 will model the raw counts, using normalization factors (size factors) to account for differences in library depth. Then, it will estimate the gene-wise dispersions and shrink these estimates to generate more accurate estimates of dispersion to model the counts. Finally, DESeq2 will fit the negative binomial model and perform hypothesis testing using the Wald test or Likelihood Ratio test. All of these steps are explained in detail in our additional materials.\n\n\n\nAll of the steps described above are conveniently performed by running the single DESeq() function on the DESeq2 object (dds) we created earlier.\n\n# Run DESeq2 differential expression analysis\ndds &lt;- DESeq(dds)\n\nEverything from normalization to linear modeling was carried out by the use of a single function! This function will print out a message for the various steps it performs:\n\nModel fitting\nThe aggregated count data generated by RNA-seq exhibits overdispersion (variance &gt; mean) and the statistical distribution used to model the counts needs to account for this. As such, DESeq2 uses a negative binomial distribution to model the RNA-seq counts using the equation below:\n\n\n\nThe two parameters required are the size factor, and the gene-wise dispersion estimate; both of which can estimated from the observed data. Next, a generalized linear model (GLM) of the NB family is used to fit the data. Modeling is a mathematically formalized way to approximate how the data behaves given a set of parameters.\n\nSize factor is used to make count values from different samples comparable. This is necessary because different samples may have been sequenced to different depths. DESeq2 uses the median of ratios method for computing a size factor for each sample.\nDispersion models the within-group variability by describing how much the variance deviates from the mean. A dispersion of 1 would indicate that there is no deviance from the mean (i.e., mean = variance). A typical RNA-seq dataset will exhibit some amount of biological variability present across replicates and so we will always have dispersion values less than one.\n\n\n\n\n\nEffect on dispersion\n\n\n\n\nVariance increases\nDispersion increases\n\n\nMean expression increases\nDispersion decreases\n\n\n\nWe can check the fit of the model to our data by looking at the plot of gene-wise dispersion estimates and how they compare with mean expression.\n\nplotDispEsts(dds)\n\n\n\n\n\nIn this plot we have dispersion on the y-axis and mean normalized counts on the x-axis. Each black dot represents a gene and its initial maximum likelihood dispersion estimate (MLE) given the observed data. Simply looking at the trend of black dots, we observe an inverse relationship between mean and dispersion.\nThe red line represents a best fit curve to the gene-wise dispersion estimates. The idea behind fitting a curve to the data is that different genes will have different scales of biological variability, but, across all genes, there will be a distribution of reasonable estimates of dispersion corresponding to a given mean expression level.\nThe blue dots represent gene-wise dispersion estimates shrunken towards values predicted by the best fit curve. The amount of shrinkage will depend on how far the initial estimate is from the curve, and that distance will vary depending on total number of replicates.\n\nIf the initial estimate (black dot) is much lower than the fitted curve, then values are shrunken up towards the red line.\nDispersion estimates that are slightly above the curve are also shrunk toward the curve for better dispersion estimation.\nGenes with extremely high dispersion values are not shrunken (these genes are shown surrounded by blue circle). This is due to the likelihood that the gene does not follow the modeling assumptions and has higher variability than others for biological or technical reasons.\n\n\nBased on the trends observed in this curve, we can say that there is a good fit of the model to the data.\n\n\n\n\n\n\nExercises\n\n\n\n\nUsing the code below, run DESeq2 for the Pdgfr α+ APCs data. Following that draw the dispersion plot. Based on this plot do you think there is a reasonable fit to the model?\n\n\n# Run DESeq2 differential expression analysis for APC\ndds_APC &lt;- DESeq(dds_APC)\n\n\n\n\n\nSetting up contrasts\nNow we need to indicate which two sample classes we are interested in comparing, and we do this by specifying contrasts. The contrasts are used as input to the DESeq2 results() function to extract the desired results.\n\n\n\n\n\n\nNote\n\n\n\nIf we run the results() function without specifying contrast or name, it will return the comparison of the last level of the last variable in the design formula over the first level of this variable. If the order of levels are not specified, they are ordered alphabetically by DESeq2.\n\n\nWe can use the resultsNames() function to guide us on exact arguments to provide when extracting our results:\n\nresultsNames(dds)\n\n[1] \"Intercept\"             \"condition_cold7_vs_TN\"\n\n\nTo denote our comparison of interest, we need to specify the contrasted groups (here, cold7 vs. `TN).\n\ncontrast &lt;- c(\"condition\", \"cold7\", \"TN\")\n\nWe use this contrast to extract results:\n\n# Results of Wald test\nres &lt;- results(dds, \n               contrast=contrast,\n               alpha = 0.05)\n\n\n\nUnderstanding the results\nNow let’s take a look at what information is stored in the results:\n\nres %&gt;% head()\n\nlog2 fold change (MLE): condition cold7 vs TN \nWald test p-value: condition cold7 vs TN \nDataFrame with 6 rows and 6 columns\n        baseMean log2FoldChange     lfcSE      stat     pvalue      padj\n       &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;  &lt;numeric&gt; &lt;numeric&gt;\nXkr4     2.80496     -0.1625561  0.941450 -0.172666 0.86291417 0.9487990\nGm1992   0.00000             NA        NA        NA         NA        NA\nRp1      0.00000             NA        NA        NA         NA        NA\nSox17    6.30657      0.3843884  0.687326  0.559252 0.57599002 0.8147941\nMrpl15 267.61120     -0.0477763  0.175316 -0.272515 0.78522621 0.9185463\nLypla1 152.10108      0.5126464  0.158363  3.237154 0.00120728 0.0133217\n\n\n\n\n\n\n\n\nWhy do I see so many NA values in my results table?\n\n\n\nThe missing values represent genes that have undergone filtering as part of the DESeq() function. Prior to differential expression analysis it is beneficial to omit genes that have little or no chance of being detected as differentially expressed. This will increase the power to detect differentially expressed genes. DESeq2 does not physically remove any genes from the original counts matrix, and so all genes will be present in your results table. For more detailed information, take a look at this lesson on gene-level filtering.\n\n\nWe should have six columns of information reported for each gene (row). We can use the mcols() function to extract information on what the values stored in each column represent:\n\n# Get information on each column in results\nmcols(res, use.names=T)\n\nDataFrame with 6 rows and 2 columns\n                       type            description\n                &lt;character&gt;            &lt;character&gt;\nbaseMean       intermediate mean of normalized c..\nlog2FoldChange      results log2 fold change (ML..\nlfcSE               results standard error: cond..\nstat                results Wald statistic: cond..\npvalue              results Wald test p-value: c..\npadj                results   BH adjusted p-values\n\n\n\nbaseMean: The mean of normalized counts for all samples\nlog2FoldChange: The log2-fold change\nlfcSE: The standard error\nstat: The Wald statistic\npvalue: The Wald test p-value\npadj: The Benjamini–Hochberg adjusted p-value\n\nThe main statistics we use for filtering these results and identifying significant genes are: pvalue, padj, and log2FoldChange. The fold changes reported in the results table are calculated by:\n\nlog2 (normalized_counts_group1 / normalized_counts_group2)\n\nThe problem is, these fold change estimates are not entirely accurate as they do not account for the large dispersion we observe with low read counts. To address this, the log2 fold changes need to be adjusted. For example, a 5 fold change for a gene which has a low mean count (e.g., 10) is not equivalent to a similar fold change observed in genes with extremeley high count (e.g., &gt; 1000). To generate more accurate log2 fold change (LFC) estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include:\n\nLow counts\nHigh dispersion values\n\nDESeq2 uses the distribution of LFC estimates for all genes to generate a prior (black solid line) to shrink the original LFC estimates of each gene (colored solid line) towards more likely (lower) LFC estimates (colored dotted line). As shown in the figure below, there is stronger shrinkage observed for genes with little information or high dispersion (purple gene).\n\n\n\nIllustration taken from the DESeq2 paper.\n\n\n\n\n\n\nNote\n\n\n\nShrinking the log2 fold changes will not change the total number of genes that are identified as significantly differentially expressed at a given padj. The shrinkage of fold change is to help with downstream assessment of results. For example, if you wanted to subset your significant genes based on fold change for further evaluation, you may want to use shrunken values. Additionally, for functional analysis tools such as GSEA that require fold change values as input, you would want to provide shrunken values.\n\n\nHere, we use the apeglm method (Zhu et al., 2018) for shrinkage estimator calculations. Alternative options for shrinkage estimation and the papers to cite if you use them are further described in the DESeq2 vignette.\n\n# Shrink the log2 fold changes to be more appropriate using the apeglm method - should cite Zhu et al., 2018 (https://doi.org/10.1093/bioinformatics/bty895) when using this method\nres &lt;- lfcShrink(dds, \n                coef = \"condition_cold7_vs_TN\",\n                res=res,\n                type = \"apeglm\")\n\nIf you take a look at the results table now, you will find fold change values may differ for some genes.\nThis is a great spot to store the results of the comparison:\n\nres %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;%\n  write.csv(\"../results/deseq2_VSM_cold7_vs_TN.csv\", row.names=F, quote=F)\n\n\n\n\n\n\n\nExercises\n\n\n\n\nGenerate results for the Pdgfr α+ APCs and save it to a variable called res_APC. There is nothing to submit for this exercise, but please run the code as you will need res_APC for future exercises."
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html",
    "href": "lessons/01_setup_intro_dataset.html",
    "title": "Project Setup and Data Exploration",
    "section": "",
    "text": "Introduce the dataset and begin setup by loading data\nDescribe the process of going from count matrix to annotated clusters\nExplore distribution of cluster annotations"
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html#learning-objectives",
    "href": "lessons/01_setup_intro_dataset.html#learning-objectives",
    "title": "Project Setup and Data Exploration",
    "section": "",
    "text": "Introduce the dataset and begin setup by loading data\nDescribe the process of going from count matrix to annotated clusters\nExplore distribution of cluster annotations"
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html#introduction-to-the-dataset",
    "href": "lessons/01_setup_intro_dataset.html#introduction-to-the-dataset",
    "title": "Project Setup and Data Exploration",
    "section": "Introduction to the dataset",
    "text": "Introduction to the dataset\nFor this workshop, we will be using the single-cell RNA-seq dataset from Shamsi et al (2021). The primary focus of this study was to evaluate the changes in brown adipose tissue (BAT) at different temperatures.\nCells were isolated from stromal vascular fraction of brown adipose tissue. After removal of all hematopoietic lineage-positive cells, 24,498 non-hematopoietic cells were re-clustered and visualisation of the clusters using UMAP identified eight major non-immune cell types present in BAT. This unsupervised clustering of gene expression profiles also revealed heterogeneity within each cell type, illustrated by the presence of multiple distinct clusters for each cell type.\n\n\n\nThe mice used in this study were housed in 4 different temperature conditions: - TN: 30 °C for 1 week - RT: 22 °C - cold2: 5 °C for 2 days - cold7: 5 °C for 7 days\nThere are four replicates per condition, except cold2 which has 3 replicates. This experimental design allowed for adequate comparison of gene expression for each celltype between conditions. For this workshop, we will be using this clustered data set as a starting point to demonstrate various approaches for identifying differentially expressed genes in single cell RNA-seq data.\n\nRaw data\nThe processed dataset is available on GEO (GSE160585) and the raw data is available for download on SRA. We chose to download the filtered counts data and metadata files, and use those to create a Seurat object as our starting point. For more detailed information and code on how to create the object from the GEO files, please see this lesson.\n\n\nRelevant metadata\nIn addition to the counts matrix, we also need to collect information about the data; this is known as metadata. There is often a temptation to just start exploring the data, but it is not very meaningful if we know nothing about the samples that this data originated from.\nSome relevant metadata for our dataset is provided below:\n\nData were generated with the 10x chromium Single Cell 3′ version 3 reagent kit\nSequenced on the NovaSeq S2 flow cell (Illumina, 100 cycles)\nProcessed with Cell Ranger 3.0.1"
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html#set-up",
    "href": "lessons/01_setup_intro_dataset.html#set-up",
    "title": "Project Setup and Data Exploration",
    "section": "Set up",
    "text": "Set up\nFor this workshop, we will be working within an RStudio project. In order to follow along you should have downloaded the R project.\n\n\n\n\n\n\nTip\n\n\n\nIf you haven’t done this already, the project can be accessed using this link.\n\n\nOnce downloaded, you should see a file called Pseudobulk_workshop.zip on your computer (likely, in your Downloads folder).\n\nUnzip this file. It will result in a folder of the same name.\nMove the folder to the location on your computer where you would like to perform the analysis.\nOpen up the folder. The contents will look like the screenshot below.\nLocate the .Rproj file and double-click on it. This will open up RStudio with the “Pseudobulk_workshop” project loaded."
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html#project-organization",
    "href": "lessons/01_setup_intro_dataset.html#project-organization",
    "title": "Project Setup and Data Exploration",
    "section": "Project organization",
    "text": "Project organization\nOne of the most important parts of research that involves large amounts of data is how best to manage it. We tend to prioritize the analysis, but there are many other important aspects of data management that are often overlooked in the excitement to get a first look at new data. The HMS Data Management Working Group discusses in-depth some things to consider beyond the data creation and analysis.\nFor each experiment you work on and analyze data for, it is considered best practice to get organized by creating a planned storage space (directory structure). We will do that for our single-cell analysis.\nLook inside your project space and you will find that a directory structure has been set up for you:\nPseudobulk_workshop/\n├── data\n├── meta\n├── results\n└── figures\n\n\n\n\n\n\nNOTE FOR WINDOWS OS users\n\n\n\nWhen you open the project folder after unzipping, please check if you have a data folder with a subfolder also called data. If this is the case, please move all the files from the subfolder into the parent data folder."
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html#loading-single-cell-rna-seq-count-data",
    "href": "lessons/01_setup_intro_dataset.html#loading-single-cell-rna-seq-count-data",
    "title": "Project Setup and Data Exploration",
    "section": "Loading single-cell RNA-seq count data",
    "text": "Loading single-cell RNA-seq count data\nNext, let’s open a new Rscript file, and start with some comments to indicate what this file is going to contain:\n\n# September 2024\n# HBC Pseduobulk workshop\n\n# Single-cell RNA-seq analysis - metadata\n\nSave the Rscript as metadata.R. Your working directory should look something like this:\nA GIF demonstrating this step is shown below:\n\n\n\n\nLoading libraries\nNext, we can load the necessary libraries:\n\n# Load libraries\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(ggalluvial)\n\n\n\nLoad Seurat object\nWe generated this Seurat object using the files that were deposited to GEO. More details on how this Seurat object was generated are detailed in another lesson, where we provide more clarity on what parameters were used for normalization, integration, and clustering.\nLet’s begin by looking at what metadata is stored inside the Seurat object, paying close attention to sample identities and celltype annotations.\n\n# Load Seurat object\nseurat &lt;- readRDS(\"../data/BAT_GSE160585_final.rds\")\ncolnames(seurat@meta.data)\n\n [1] \"orig.ident\"             \"nCount_RNA\"             \"nFeature_RNA\"          \n [4] \"sample\"                 \"log10GenesPerUMI\"       \"mitoRatio\"             \n [7] \"condition\"              \"S.Score\"                \"G2M.Score\"             \n[10] \"Phase\"                  \"CC.Difference\"          \"nCount_SCT\"            \n[13] \"nFeature_SCT\"           \"integrated_snn_res.1.2\" \"celltype\"              \n[16] \"seurat_clusters\"       \n\n\nA nice way to observe patterns or trends in the data is to visualize it, especially when we are working with such a large number of cells!\n\n\nSample distribution\nRecall from the summary above that we have cells from four different conditions. We can use a barplot to show the number of cells for each replicate, coloring each sample by the temperature condition the mice were subjected to. This provides an overview of the number of cells we are working with for each replicate. This metric is important to bear in mind as we need to ensure that we have enough cells to run future analyses.\n\n# Number of cells per sample\nggplot(seurat@meta.data) +\n    geom_bar(aes(x=sample, fill=condition),\n             stat=\"count\", color=\"black\") +\n    theme_classic() +\n    theme(axis.text.x = element_text(angle=45, vjust=1, hjust=1)) +\n    labs(x=\"Sample name\", y=\"Number of cells\")\n\n\n\n\nWe can also see the distribution of cells across the UMAP for each replicate and sample. As this dataset has already been processed and integrated, we expect the cells to be integrated together - where there are no cells grouping together due to a batch effect (i.e sample). Instead the cells should be clustered together based upon gene expression similarity, which would ideally lead to celltypes being grouped together.\n\n# UMAPs of condition and sample\nDimPlot(seurat, group.by=c(\"sample\", \"condition\"))\n\n\n\n\n\n\nCelltype annotation\nIntially, cells were clustered at a range of resolutions. The authors chose a resolution 1.2 as it grouped cells adequately into the celltypes of interest.\n\n# UMAP clusters\np &lt;- DimPlot(seurat, group.by=\"seurat_clusters\") + NoLegend()\nLabelClusters(p, id = \"seurat_clusters\",  fontface = \"bold\", \n              size = 5, bg.colour = \"white\", bg.r = .2, force = 0)\n\n\n\n\nUsing these clusters and a variety of marker genes, the cells were annotated into 8 major non-immune cell types:\n\nPdgfra+ adipose progenitors (AP)\nVascular endothelial (ECAP, EC)\nLymphatic endothelial (Lymph)\nVascular smooth muscle cells (VSM)\nPericytes (Pericyte)\nAdipocytes (Adipo)\nMyelinating Schwann cells (Schwann)\nNon-myelinating Schwann cells (Schwann)\n\nNotable marker genes from the paper are represented here using the FeaturePlot() function. Here we can see that indeed the cells are grouping together based upon gene expression and celltype identities.\n\nFeaturePlot(seurat, c(\"Pdgfra\", \"Acta2\", \"Cdh5\", \n                      \"Lyve1\", \"Ucp1\", \"Mpz\"))\n\n\n\n\nThe mapping of cluster to celltypes is being represented here as an alluvial plot. This visualization provides a quick way to see which clusters have been annotated as which celltype.\n\n# Order clusters numerically\norder_cluster &lt;- unique(seurat$seurat_clusters) %&gt;% as.numeric() %&gt;% sort() %&gt;% as.character()\nseurat$seurat_clusters &lt;- factor(seurat$seurat_clusters, levels=order_cluster)\n\n# Map clusters to celltypes\nggplot(seurat@meta.data,\n        aes(axis1 = seurat_clusters,\n            axis2 = celltype,\n            fill = celltype)) +\n    geom_alluvium() +\n    geom_stratum() +\n    geom_text(stat = \"stratum\",\n        aes(label=after_stat(stratum))) +\n    theme_void() +\n    NoLegend() +\n    coord_flip()\n\n\n\n\nWith these updated celltype labels, we can see how they distribute on the UMAP.\n\n# UMAP celltype\nIdents(seurat) &lt;- \"celltype\"\np &lt;- DimPlot(seurat) + NoLegend()\nLabelClusters(p, id = \"ident\",  fontface = \"bold\", size = 4,\n              bg.colour = \"white\", bg.r = .2, force = 0)\n\n\n\n\nWe can even identify celltypes of interest based upon the proportion of cells in each experimental condition.\n\n# Barplot sample proportion by celltype \nggplot(seurat@meta.data) +\n    geom_bar(aes(x=celltype, fill=condition), \n                 position=position_fill(), color=\"black\") +\n    theme_classic() +\n    labs(x=\"Celltype\", y=\"Proportion of cells\")\n\n\n\n\nNow that we have a better understanding of what data we have available to us, we can begin our analysis!"
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html",
    "href": "lessons/03_pseudobulk_DESeq2.html",
    "title": "Set-up DESeq2 analysis",
    "section": "",
    "text": "Approximate time: 40 minutes"
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#learning-objectives",
    "href": "lessons/03_pseudobulk_DESeq2.html#learning-objectives",
    "title": "Set-up DESeq2 analysis",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nPrepare single-cell RNA-seq raw count data for pseudobulk differential expression analysis\nCreate a DESeq2 object for differential expression analysis on a specific cell type cluster"
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#pseudobulk-differential-expression-analysis",
    "href": "lessons/03_pseudobulk_DESeq2.html#pseudobulk-differential-expression-analysis",
    "title": "Set-up DESeq2 analysis",
    "section": "Pseudobulk differential expression analysis",
    "text": "Pseudobulk differential expression analysis\nIn the previous lesson we demonstrated how to perform a differential expression analysis using the FindMarkers() function in Seurat. The major limitation of this approach is that it treats each individual cell as a replicate, which inflates the p-value, resulting in many false positives. In this lesson we introduce you to the pseudobulk approach, in which cells belonging to a cluster are aggregated within each sample to create a gene by sample count matrix. This count matrix resembles the input we use for bulk RNA-seq, and we use a similar workflow to identify differentially expressed genes.\n\n\n\nForming pseudobulk samples is important to perform accurate differential expression analysis. Cells from the same sample/individual are more similar to each other than to cells from another individual. This means treating each cell as an independent sample leads to underestimation of the variance and misleadingly small p-values. Working on the level of pseudobulk ensures reliable statistical tests because the samples correspond to the units of replication.\nUsing a pseudobulk approach involves the following steps:\n\nSubsetting to the cells for the cell type(s) of interest to perform the DE analysis;\nExtracting the raw counts after QC filtering of cells to be used for the DE analysis;\nAggregating the counts and metadata to the sample level;\nPerforming the DE analysis (you need at least two biological replicates per condition to perform the analysis, but more replicates are recommended)."
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#setting-up",
    "href": "lessons/03_pseudobulk_DESeq2.html#setting-up",
    "title": "Set-up DESeq2 analysis",
    "section": "Setting up",
    "text": "Setting up\nLet’s begin by opening a new Rscript file, and include a commentheader line:\n\n# Single-cell RNA-seq analysis - Pseudobulk DE analysis with DESeq2\n\nSave the Rscript as DE_analysis_scrnaseq.R.\n\nLoad libraries\nNext, let’s load the libraries that we will be using for the analysis:\n\n# Load libraries\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(DESeq2)\nlibrary(pheatmap)\nlibrary(EnhancedVolcano)\nlibrary(RColorBrewer)\nlibrary(cowplot)\nlibrary(dplyr)\nlibrary(ggrepel)\n\n\n\nCreate metadata\nWe will want to create a dataframe with all of the sample-level metadata, this will be used during the aggregation step but also later with differential expression analysis.\n\n\n\n\n\n\nNote\n\n\n\nOther relevant metadata for a pseudobulk differential expression analysis include information about the individuals that will be contrasted (age, sex, clinical presentation, etc.). The more information you can collect about your study samples, the better!_\n\n\n\nmeta_columns &lt;- c(\"sample\", \"condition\")\nmeta &lt;- seurat@meta.data %&gt;%\n            select(meta_columns) %&gt;%\n            unique() %&gt;%\n            remove_rownames()\n\nmeta\n\n      sample condition\n1   Sample_1        TN\n2   Sample_2        TN\n3   Sample_9        TN\n4  Sample_10        TN\n5   Sample_3        RT\n6   Sample_4        RT\n7  Sample_11        RT\n8  Sample_12        RT\n9   Sample_6     cold2\n10 Sample_13     cold2\n11 Sample_14     cold2\n12  Sample_7     cold7\n13  Sample_8     cold7\n14 Sample_15     cold7\n15 Sample_16     cold7"
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#aggregate-counts-for-pseudobulk-analysis",
    "href": "lessons/03_pseudobulk_DESeq2.html#aggregate-counts-for-pseudobulk-analysis",
    "title": "Set-up DESeq2 analysis",
    "section": "Aggregate counts for pseudobulk analysis",
    "text": "Aggregate counts for pseudobulk analysis\nNow, before we transform our single-cell level dataset into one sample-level dataset per cell type (cluster), there are a few data wrangling steps involved. We know that we want to aggregate cells of a particular celltype and that we want to collapse them down by sample.\nTo aggregate the counts, we will use the AggregateExpression() function from Seurat. It will take as input a Seurat object, and return summed counts (“pseudobulk”) for each identity class. The default is to return a matrix with genes as rows, and identity classes as columns. We have set return.seurat to TRUE, which means rather than a matrix we will get an object of class Seurat. We have also specified which factors to aggregate on, using the group.by argument.\n\nbulk &lt;- AggregateExpression(\n            seurat,\n            return.seurat = TRUE,\n            assays = \"RNA\",\n            group.by = c(\"celltype\", \"sample\", \"condition\")\n)\nbulk\n\nAn object of class Seurat \n19771 features across 133 samples within 1 assay \nActive assay: RNA (19771 features, 0 variable features)\n 3 layers present: counts, data, scale.data\n\n\nNow our Seurat object has ‘cells’ that correspond to aggregated counts. We will see that the samples have the name “{celltype}_{sample}_{condition}” to show that we are grouping together counts based on sample, celltype, and condition. The metadata columns that were used as input are included in this new Seurat object as well.\n\n# each 'cell' is a sample-condition-celltype pseudobulk profile\ntail(Cells(bulk))\n\n[1] \"VSM-AP_Sample-3_RT\"    \"VSM-AP_Sample-4_RT\"    \"VSM-AP_Sample-6_cold2\"\n[4] \"VSM-AP_Sample-7_cold7\" \"VSM-AP_Sample-8_cold7\" \"VSM-AP_Sample-9_TN\"   \n\n\nNow would be the time to add to your metadata any other information you have on the samples. For example, adding the number of cells we aggregated on is useful information to include.\n\n# Number of cells by sample and celltype\nn_cells &lt;- seurat@meta.data %&gt;% \n              dplyr::count(sample, celltype) %&gt;% \n              rename(\"n\"=\"n_cells\")\nn_cells$sample &lt;- str_replace(n_cells$sample, \"_\", \"-\")\n\nmeta_bulk &lt;- left_join(bulk@meta.data, n_cells)\nrownames(meta_bulk) &lt;- meta_bulk$orig.ident\nbulk@meta.data &lt;- meta_bulk\n\n# Turn condition into a factor\nbulk$condition &lt;- factor(bulk$condition, levels=c(\"TN\", \"RT\", \"cold2\", \"cold7\"))\n\nbulk@meta.data %&gt;% head()\n\n                                 orig.ident celltype    sample condition\nAdipo_Sample-1_TN         Adipo_Sample-1_TN    Adipo  Sample-1        TN\nAdipo_Sample-11_RT       Adipo_Sample-11_RT    Adipo Sample-11        RT\nAdipo_Sample-12_RT       Adipo_Sample-12_RT    Adipo Sample-12        RT\nAdipo_Sample-13_cold2 Adipo_Sample-13_cold2    Adipo Sample-13     cold2\nAdipo_Sample-14_cold2 Adipo_Sample-14_cold2    Adipo Sample-14     cold2\nAdipo_Sample-15_cold7 Adipo_Sample-15_cold7    Adipo Sample-15     cold7\n                      n_cells\nAdipo_Sample-1_TN           5\nAdipo_Sample-11_RT          7\nAdipo_Sample-12_RT         43\nAdipo_Sample-13_cold2      28\nAdipo_Sample-14_cold2     491\nAdipo_Sample-15_cold7      15\n\n\nThe output of this aggregation is a sparse matrix and, when we take a quick look, we can see that it is a gene by celltype-sample matrix.\n\nbulk[[\"RNA\"]]$counts[1:5, 1:5]\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n       Adipo_Sample-1_TN Adipo_Sample-11_RT Adipo_Sample-12_RT\nXkr4                   1                  .                  .\nGm1992                 .                  .                  .\nRp1                    .                  .                  .\nSox17                  .                  .                  .\nMrpl15                 5                 23                106\n       Adipo_Sample-13_cold2 Adipo_Sample-14_cold2\nXkr4                       .                     .\nGm1992                     .                     .\nRp1                        .                     .\nSox17                      .                     .\nMrpl15                   135                  2037\n\n\n\n\nClick here for alternative code for aggregating counts for multiple celltypes\n\nNote that this code uses a for loop. This will first subset out cells by celltype and then aggregate, creating a list of pseudobulked Seurat objects. First, we create a vector of unique celltypes in our data so that we can iterate over each one of them. \ncelltypes &lt;- sort(unique(seurat@meta.data[[\"celltype\"]]))\ncelltypes\n\n[1] \"Adipo\"    \"AP\"       \"EC\"       \"ECAP\"     \"Lymph\"    \"Pericyte\" \"Schwann\" \n[8] \"VSM\"      \"VSM-AP\"  \n\n\nNext, we want to store the aggregated, pseudobulked expression for each celltype as a list of Seurat objects. Therefore we are going to use the same steps we ran above with the AggregateExpression() function and adding the number of cells in each group as a metadata column. \npb_list &lt;- list()\nfor (ct in celltypes) {\n  \n  # Subset cells to one celltype\n  seurat_ct &lt;- subset(seurat, subset=(celltype == ct))\n  \n  # Aggregate to get pseudobulk\n  bulk_ct &lt;- AggregateExpression(\n              seurat_ct,\n              return.seurat = T,\n              assays = \"RNA\",\n              group.by = c(\"celltype\", \"sample\", \"condition\")\n            )\n  \n  # Add number of cells per sample\n  n_cells &lt;- seurat_ct@meta.data %&gt;% \n                dplyr::count(sample, celltype) %&gt;% \n                rename(\"n\"=\"n_cells\")\n  n_cells$sample &lt;- str_replace(n_cells$sample, \"_\", \"-\")\n  meta_bulk_ct &lt;- left_join(bulk_ct@meta.data, n_cells)\n  rownames(meta_bulk_ct) &lt;- meta_bulk_ct$orig.ident\n  bulk_ct@meta.data &lt;- meta_bulk_ct\n  \n  pb_list[[ct]] &lt;- bulk_ct\n  \n}"
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#differential-gene-expression-with-deseq2",
    "href": "lessons/03_pseudobulk_DESeq2.html#differential-gene-expression-with-deseq2",
    "title": "Set-up DESeq2 analysis",
    "section": "Differential gene expression with DESeq2",
    "text": "Differential gene expression with DESeq2\nWe will be using DESeq2 for the pseudobulk DE analysis, and the analysis steps with DESeq2 are shown in the flowchart below in green and blue. DESeq2 first normalizes the count data to account for differences in library sizes and RNA composition between samples. Then, we will use the normalized counts to make some plots for QC at the gene and sample level. The final step is to use the appropriate functions from the DESeq2 package to perform the differential expression analysis. We will go into each of these steps briefly, but additional details and helpful suggestions regarding DESeq2 can be found in our materials detailing the workflow for bulk RNA-seq analysis, as well as in the DESeq2 vignette."
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#creating-a-deseq2-object",
    "href": "lessons/03_pseudobulk_DESeq2.html#creating-a-deseq2-object",
    "title": "Set-up DESeq2 analysis",
    "section": "Creating a DESeq2 object",
    "text": "Creating a DESeq2 object\nFrom the pseudobulk Seurat object, we can extract the information required as the input to DESeq2. First, we need to decide which cell type we wish to focus on, and then retrieve the corresponding data from the object. We are going to look for differntially expressed genes between the TN and cold7 condition for the vascular smooth muscle (VSM) cells.\nWe use the subset() function to get the data we need:\n\nbulk_vsm &lt;- subset(bulk, subset= (celltype == \"VSM\") & \n                     (condition %in% c(\"TN\", \"cold7\")))\nbulk_vsm\n\nAn object of class Seurat \n19771 features across 8 samples within 1 assay \nActive assay: RNA (19771 features, 0 variable features)\n 3 layers present: counts, data, scale.data\n\n\n\nNumber of cells\nBefore moving on to a pseudobulk DGE analysis, it is important to identify how many cells we aggregated for each sample. We need to make sure that we have enough cells per sample after subsetting to one celltype. We can see that with the exception of one sample, the TN group has many cells and the cold7 samples have much fewer cells.\n\nggplot(bulk_vsm@meta.data, aes(x=sample, y=n_cells, fill=condition)) +\n    geom_bar(stat=\"identity\", color=\"black\") +\n    theme_classic() +\n    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +\n    labs(x=\"Sample name\", y=\"Number of cells\") +\n    geom_text(aes(label=n_cells), vjust=-0.5)\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nAnother cell type in this dataset that was particularly interesting to the authors were the Pdgfr α+ adipose progentior cells (APCs).\n\nSubset the bulk object to isolate only adipose progenitor cells for the TN and cold7 conditions. Assign it to variable called bulk_APC.\n\nHint: You may need to review celltypes to determine what this cell type is called in our data. You can find unique celltypes with the code:\n\ncelltypes &lt;- sort(unique(seurat@meta.data[[\"celltype\"]]))\n\n\nReminder: The abbreviations for the cell types can be found in the project set-up lesson.\n\n\nPlot the cell number distribution across samples. How do the numbers compare to VSM cells?\n\n\n\nNow we can create our DESeq2 object to prepare to run the DE analysis. We need to include the counts, metadata, and design formula for our comparison of interest. In the design formula we should also include any other columns in the metadata for which we want to regress out the variation (batch, sex, age, etc.). For this dataset, we only have our comparison of interest, which is stored as the condition in our metadata data frame.\nMore information about the DESeq2 workflow and design formulas can be found in our DESeq2 materials.\n\n# Get count matrix\ncluster_counts &lt;- FetchData(bulk_vsm, layer=\"counts\", vars=rownames(bulk_vsm))\n\n# Create DESeq2 object\n# transpose it to get genes as rows\ndds &lt;- DESeqDataSetFromMatrix(t(cluster_counts),\n                                colData = bulk_vsm@meta.data,\n                                design = ~ condition)\n\ndds\n\nclass: DESeqDataSet \ndim: 19771 8 \nmetadata(1): version\nassays(1): counts\nrownames(19771): Xkr4 Gm1992 ... CAAA01118383.1 CAAA01147332.1\nrowData names(0):\ncolnames(8): VSM_Sample-1_TN VSM_Sample-10_TN ... VSM_Sample-8_cold7\n  VSM_Sample-9_TN\ncolData names(5): orig.ident celltype sample condition n_cells\n\n\nNow that the DESeq2 object is created, we are ready to continue with our analysis!\n\n\n\n\n\n\nExercises\n\n\n\n\nUsing the code below, create a DESeq2 object for the Pdgfr α+ APCs data. There is nothing to submit for this exercise, but please run the code as you will need dds_APC for future exercises.\n\n\n# Get count matrix\nAPC_counts &lt;- FetchData(bulk_APC, layer=\"counts\", vars=rownames(bulk_APC))\n\n# Create DESeq2 object\n# transpose it to get genes as rows\ndds_APC &lt;- DESeqDataSetFromMatrix(t(APC_counts),\n                                colData = bulk_APC@meta.data,\n                                design = ~ condition)\n\ndds_APC"
  },
  {
    "objectID": "lessons/00_counts_to_clusters_overview.html",
    "href": "lessons/00_counts_to_clusters_overview.html",
    "title": "Single-cell RNA-seq: From Counts to Clusters",
    "section": "",
    "text": "Approximate time: 20 minutes"
  },
  {
    "objectID": "lessons/00_counts_to_clusters_overview.html#learning-objectives",
    "href": "lessons/00_counts_to_clusters_overview.html#learning-objectives",
    "title": "Single-cell RNA-seq: From Counts to Clusters",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDescribe the workflow for single-cell RNA-seq analysis starting from a count matrix through to annotated celltypes"
  },
  {
    "objectID": "lessons/00_counts_to_clusters_overview.html#filtering-data",
    "href": "lessons/00_counts_to_clusters_overview.html#filtering-data",
    "title": "Single-cell RNA-seq: From Counts to Clusters",
    "section": "Filtering data",
    "text": "Filtering data\nThe first step is to take the raw count data and use various metrics to identify true cells that are of high quality, so that when we cluster our cells it is easier to identify distinct cell type populations. Visualizing metrics with plots allows us to evaluate all samples within a dataset and isolate any problematic samples. Additionally, we can more easily decide on suitable thresholds for cell-level filtering. We want to be able to keep as many high quality cells as possible without removing biologically relevant cell types. Gene-level filtering is also applied at this stage."
  },
  {
    "objectID": "lessons/00_counts_to_clusters_overview.html#clustering-workflow",
    "href": "lessons/00_counts_to_clusters_overview.html#clustering-workflow",
    "title": "Single-cell RNA-seq: From Counts to Clusters",
    "section": "Clustering workflow",
    "text": "Clustering workflow\nFor something to be informative, it needs to exhibit variation, but not all variation is informative. The goal of our clustering analysis is to keep the major sources of variation in our dataset that should define our cell types, while restricting the variation due to uninteresting sources of variation (sequencing depth, cell cycle differences, mitochondrial expression, batch effects, etc.). Then, to determine the cell types present, we will perform a clustering analysis using the most variable genes to define the major sources of variation in the dataset.\nThe workflow for this analysis is adapted from the following sources:\n\nSatija Lab: Seurat v3 Guided Integration Tutorial\nPaul Hoffman: Cell-Cycle Scoring and Regression\n\nTo identify clusters, the following steps are performed:\n\n1. Explore sources of unwanted variation\nThe first step in the workflow is to see if our data contains any unwanted variability. The most common biological effect that is evaluated in single-cell RNA-seq data is the effect of cell cycle on the transcriptome. Another known biological effect is mitochondrial gene expression, which is interpreted as an indication of cell stress. This step of the workflow involves exploring our data to identify which covariates we would like to regress out.\n\n\n\n2. Normalization and regressing out sources of unwanted variation\nNormalization is required to scale the raw count data to obtain correct relative gene expression abundances between cells. The sctransform function implements an advanced normalization and variance stabilization of the data. The sctransform function also regresses out sources of unwanted variation in our data. In the previous step, we had identified these sources of variability, and here we specify what those covariates are.\n\nImage credit: Hafemeister C and Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genom Biology 2019 https://doi.org/10.1101/576827\n\n\n3. Integration\nOften with single cell RNA-seq we are working with multiple samples which correspond to different sample groups, multiple experiments or different modalities. If we want to ultimately compare celltype expression between groups it is recommended to integrate the data. Integration is a powerful method that uses these shared sources of greatest variation to identify shared sub-populations across conditions or datasets (Stuart and Butler et al. (2018)). There are several steps involved in performing intergration in Seurat. Once complete, we use visualization methods to ensure a good integration before we proceed to cluster cells.\n\n\n\n\n\n\n\nNote\n\n\n\nIntegration is optional. We recommend going through the workflow without integration to decide whether or not it is necessary for your data.\n\n\n\n\n4. Clustering cells\nClusters of cells are obtained by grouping cells based on the similarity of their gene expression profiles. Expression profile similarity is determined via distance metrics, which often take dimensionality‐reduced representations as input. Seurat assigns cells to clusters based on their PCA scores derived from the expression of the integrated most variable genes.\n\n\n\n5. Cluster quality evaluation\nThe clusters identified in our data represent groups of cells that presumably belong to a similar cell type. Before we can confirm the celltype of a group of member cells, the following steps are taken:\n\na. Check to see that clusters are not influenced by sources of uninteresting variation.\nb. Check to see whether the major principal components are driving the different clusters.\nc. Explore the cell type identities by looking at the expression for known markers across the clusters."
  },
  {
    "objectID": "lessons/00_counts_to_clusters_overview.html#marker-identification-and-celltype-assignment",
    "href": "lessons/00_counts_to_clusters_overview.html#marker-identification-and-celltype-assignment",
    "title": "Single-cell RNA-seq: From Counts to Clusters",
    "section": "Marker Identification and Celltype Assignment",
    "text": "Marker Identification and Celltype Assignment\nOften the known marker expression evaluation gives us some hints as to which celltype is represented within a cluster, but sometimes it is not so obvious. In situations where there is uncertainty of the cell type assignment it is good practice to check which genes exhibit a high expression profile among cells (i.e FindMarkers). The list of genes can provide insight on celltype and/or can be the impetus for removal of a group of cells. After this step we hope to obtain a fully annotated dataset that we can move forward with for downstream analysis."
  },
  {
    "objectID": "lessons/01b_gen_seurat_object.html",
    "href": "lessons/01b_gen_seurat_object.html",
    "title": "Sample pre-processing",
    "section": "",
    "text": "Approximate time: 15 minutes"
  },
  {
    "objectID": "lessons/01b_gen_seurat_object.html#learning-objectives",
    "href": "lessons/01b_gen_seurat_object.html#learning-objectives",
    "title": "Sample pre-processing",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nUnderstand the steps taken to generate the Seurat object used as input for the workshop."
  },
  {
    "objectID": "lessons/01b_gen_seurat_object.html#sample-data",
    "href": "lessons/01b_gen_seurat_object.html#sample-data",
    "title": "Sample pre-processing",
    "section": "Sample data",
    "text": "Sample data\nFor this workshop, we will be working with a single-cell RNA-seq dataset from Tseng et al, 2021. The data is available on GEO GSE160585. The files we will need to create the fully processed Seurat object include:\n\nMetadata csv file\nCounts matrix\nList of features (genes)\nList of cell barcodes\n\nWe have an entire workshop of materials that go through the whole process step-by-step on how to generate a similarly fully annotated, filtered dataset from single-cell RNA-seq data. In this lesson we provide mostly code, so you can reproduce the object yourself. If you want an in-depth explanation of each step we encourage you to peruse the materials linked above."
  },
  {
    "objectID": "lessons/01b_gen_seurat_object.html#pre-processing-steps",
    "href": "lessons/01b_gen_seurat_object.html#pre-processing-steps",
    "title": "Sample pre-processing",
    "section": "Pre-processing steps",
    "text": "Pre-processing steps\n\nDownload and unzip the dataset from GEO using bash:\n\n\n#!/bin/bash\n\n# Create data directory to store downloaded files\nmkdir -p data/filtered_counts\n\n# Metadata csv file\nwget wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE160nnn/GSE160585/suppl/GSE160585%5Fmetadata%5Ffor%5Fpseudotime%5Fand%5Fpseudobulk%5FDGE.csv.gz -O data/meta.csv.gz\n\n# Features, barcodes, and counts matrix\nwget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE160nnn/GSE160585/suppl/GSE160585%5Ffiltered%5Fraw%5Fcounts%5Ffor%5Fpseudotime%5Fand%5Fpseudobulk%5FDGE.tar.gz -O data/filtered_counts.tar.gz\n\n# Unzip and decompress the files\ntar -xvf data/filtered_counts.tar.gz -C data/filtered_counts\ngunzip data/meta.csv.gz\n\n\nData wrangling of the metadata\n\n\nlibrary(tidyverse)\nmeta &lt;- read.csv(\"data/meta.csv\", row.names=1)\n\n# Celltype IDs have are formatted like: \n# {celltype}_{cluster}\n# Removing the underscore\nmeta$celltype &lt;- sub(\"_.*\", \"\", meta$cluster_id)\nmeta &lt;- select(meta, -c(cluster_id))\n\n# The following columns in the metadata have duplicate values:\n# - nCount_RNA = nUMI\n# - nFeature_RNA = nGene\nmeta &lt;- select(meta, -c(nUMI, nGene))\n\n# Rename columns for more clarity\nmeta &lt;- meta %&gt;%\n    rename(c(\"orig.ident\"=\"sample\", \"sample\"=\"condition\"))\n\n\n# Removing cluster resolutions that will not be used\ncols &lt;- c(\n    \"integrated_snn_res.0.1\",\n    \"integrated_snn_res.0.4\",\n    \"integrated_snn_res.0.6\",\n    \"integrated_snn_res.0.8\",\n    \"integrated_snn_res.1\",\n    # \"integrated_snn_res.1.2\",\n    \"integrated_snn_res.1.4\",\n    \"integrated_snn_res.1.8\",\n    \"seurat_clusters\"\n)\n\nmeta &lt;- meta %&gt;% select(-c(cols))\n\n# Store clusters IDs as factors\nmeta$seurat_clusters &lt;- meta$integrated_snn_res.1.2\nsorted_cluster &lt;- sort(as.integer(unique(meta$seurat_clusters)))\nmeta$seurat_clusters &lt;- factor(meta$seurat_clusters, levels=sorted_cluster)\n\n\nGenerate Seurat object using downloaded files as input\n\n\nlibrary(Seurat)\nlibrary(Matrix)\nset.seed(1454944673L) # Using the same seed used in the paper\n\n# Load metadata, barcodes, features, and matrix into R\nbarcodes &lt;- read.csv(\"data/filtered_counts/barcodes_filtered_raw_counts_for_pseudotime_and_pseudobulk_DGE.tsv\", header=FALSE)\nfeatures &lt;- read.csv(\"data/filtered_counts/genes_filtered_raw_counts_for_pseudotime_and_pseudobulk_DGE.tsv\", header=FALSE)\ncounts &lt;- readMM(\"data/filtered_counts/filtered_raw_counts_for_pseudotime_and_pseudobulk_DGE.mtx\")\n\n# Add gene and cell barcode information to count matrix\nrow.names(counts) &lt;- features$V1\ncolnames(counts) &lt;- barcodes$V1\n\n# Create seurat object\nseurat &lt;- CreateSeuratObject(\n    counts, \n    project = \"GSE160585\", \n    assay = \"RNA\", \n    meta.data = meta)\n\n\n\n\n\n\n\nNote\n\n\n\nIn the next few steps we have provided the code to process the Seurat object. The parameters for each step were chosen based upon the descriptions provided in the Methods section of the paper.\n\n\n\nLog-normalization and highly variable genes\n\n\n# Log normalization\nseurat &lt;- NormalizeData(seurat)\n\n# Identify the most variable genes\nseurat &lt;- FindVariableFeatures(seurat, \n                     selection.method = \"vst\",\n                     nfeatures = 3000, \n                     verbose = FALSE)\n\n\nSCTransform and regress out cell cycle scores\n\n\n# Split seurat object by sample\nsplit_seurat &lt;- SplitObject(seurat, split.by = \"condition\")\n\n# Allow R to use more memory\noptions(future.globals.maxSize = 4000 * 1024^2)\n\n# Run SCTranform on each sample individually\nfor (i in 1:length(split_seurat)) {\n    # Regress out cell cycle scores\n    split_seurat[[i]] &lt;- SCTransform(split_seurat[[i]], \n                                    vars.to.regress = c(\"S.Score\", \"G2M.Score\"), \n                                    vst.flavor = \"v2\",\n                                    variable.features.n = 3000)\n}\n\n\nCCA integration\n\n\n# Select the most variable features to use for integration\ninteg_features &lt;- SelectIntegrationFeatures(object.list = split_seurat, \n                                            nfeatures = 3000)\n# Prepare the SCT list object for integration\nsplit_seurat &lt;- PrepSCTIntegration(object.list = split_seurat,\n                                    anchor.features = integ_features)\n# Find best buddies - can take a while to run\ninteg_anchors &lt;- FindIntegrationAnchors(object.list = split_seurat,\n                                        normalization.method = \"SCT\",\n                                        anchor.features = integ_features)\n# Integrate across conditions\nseurat_integrated &lt;- IntegrateData(anchorset = integ_anchors, \n                                    normalization.method = \"SCT\")\n\n# Rejoin the layers in the RNA assay that we split earlier\nseurat_integrated[[\"RNA\"]] &lt;- JoinLayers(seurat_integrated[[\"RNA\"]])\n\n\nPCA, nearest neighbors, UMAP\n\n\nseurat_integrated &lt;- RunPCA(seurat_integrated, verbose = FALSE)\nseurat_integrated &lt;- RunUMAP(seurat_integrated, dims = 1:50)\nseurat_integrated &lt;- FindNeighbors(seurat_integrated, dims = 1:50)\n\n\nSave seurat object\n\n\nIdents(seurat_integrated) &lt;- \"condition\"\nDefaultAssay(seurat_integrated) &lt;- \"RNA\"\n\nsaveRDS(seurat_integrated, \"data/BAT_GSE160585.rds\")"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html",
    "title": "DE analysis using FindMarkers",
    "section": "",
    "text": "Approximate time: 75 minutes"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#learning-objectives",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#learning-objectives",
    "title": "DE analysis using FindMarkers",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nEvaluate differential gene expression between conditions using a Wilcoxon rank sum test\nCreate visualizations for differentially expressed genes\nDiscuss other statistical tests for differential expression analysis"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#differential-expression-between-conditions-using-findmarkers",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#differential-expression-between-conditions-using-findmarkers",
    "title": "DE analysis using FindMarkers",
    "section": "Differential expression between conditions using FindMarkers()",
    "text": "Differential expression between conditions using FindMarkers()\nIn our current UMAP, we have merged samples across the different conditions and used integration to align cells of the same celltype across samples. Now, what if we were interested in a particular celltype and understanding how gene expression changes across the different conditions?\nThe FindMarkers() function in the Seurat package is used to perform differential expression analysis between groups of cells. We provide arguments to specify ident.1 and ident.2 the two groups of cells we are interested in comparing. This function is commonly used at the celltype annotation step, but can also be used to calculate differentially expressed genes between experimental conditions.\n\n\n\nWe can use this same function to compare two groups of cells which represent different conditions by modifying the ident values provided. The FindMarkers() function has several important arguments we can modify when running it. To view what these parameters are, we can access the help page on this function:\n\n?FindMarkers\n\nBelow we have described in more detail what each of these arguments mean :\n\nlogfc.threshold: The minimum log2 fold change for average expression of gene in group relative to the average expression in all other groups combined. Default is 0.25.\nmin.diff.pct: The minimum percent difference between the percent of cells expressing the gene in the group and the percent of cells expressing gene in all other groups combined.\nmin.pct: Only test genes that are detected in a minimum fraction of cells in either of the two populations. Meant to speed up the function by not testing genes that are very infrequently expressed. Default is 0.1.\nident.1: This function only evaluates one group at a time; here you would specify the group of interest. These values must be set in the Idents().\nident.2: Here you would specify the group you want to compare ident.1 against."
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#setting-up",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#setting-up",
    "title": "DE analysis using FindMarkers",
    "section": "Setting up",
    "text": "Setting up\nOpen up a new Rscript file, and start with some comments to indicate what this file is going to contain:\n\n# Single-cell RNA-seq DE analysis - FindMarkers\n\nSave the Rscript as findMarkers.R.\n\nLoad libraries\nNow let’s load the required libraries for this analysis:\n\n# Load libraries\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(EnhancedVolcano)"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#findmarkers",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#findmarkers",
    "title": "DE analysis using FindMarkers",
    "section": "FindMarkers()",
    "text": "FindMarkers()\nTo use the function to look for DE genes between conditions, there are two things we need to do:\n\nSubset the Seurat object to our celltype of interest\nSet our active Idents to be the metadata column which specifies what condition each cell is\n\nIn our example we are focusing on vascular smooth muscle (VSM) cells. The comparison we will be making is TN vs. cold7.\n\n# Subset the object\nseurat_vsm &lt;- subset(seurat, subset = (celltype == \"VSM\"))\n\n# Set the idents\nIdents(seurat_vsm) &lt;- \"condition\"\nseurat_vsm\n\nAn object of class Seurat \n40338 features across 12372 samples within 3 assays \nActive assay: RNA (19771 features, 3000 variable features)\n 2 layers present: data, counts\n 2 other assays present: SCT, integrated\n 2 dimensional reductions calculated: pca, umap\n\n\nBefore we make our comparisons we will explicitly set our default assay, we want to use the normalized data, not the integrated data.\n\n# Set default assay\nDefaultAssay(seurat_vsm) &lt;- \"RNA\"\n\nThe default assay should have already been RNA, but we encourage you to run this line of code above to be absolutely sure in case the active slot was changed somewhere upstream in your analysis.\n\n\n\n\n\n\nWhy don’t we use SCT normalized data?\n\n\n\nNote that the raw and normalized counts are stored in the counts and data slots of RNA assay, respectively. By default, the functions for finding markers will use normalized data if RNA is the DefaultAssay. The number of features in the RNA assay corresponds to all genes in our dataset.\nNow if we consider the SCT assay, functions for finding markers would use the scale.data slot which is the pearson residuals that come out of regularized NB regression. Differential expression on these values can be difficult interpret. Additionally, only the variable features are represented in this assay and so we may not have data for some of our marker genes.\n\n\nNow we can run FindMarkers():\n\n# Determine differentiating markers for TN and cold7\ndge_vsm &lt;- FindMarkers(seurat_vsm,\n                       ident.1=\"cold7\",\n                       ident.2=\"TN\"\n                       )\n\nNow let’s take a quick look at the results:\n\n# View results \ndge_vsm %&gt;% head()\n\n                p_val avg_log2FC pct.1 pct.2     p_val_adj\nGm42418 4.492261e-223  1.8013603 0.999 0.986 8.881650e-219\nUbb     1.801612e-207 -0.8274973 0.982 0.999 3.561968e-203\nH3f3b   6.044423e-198 -0.9395566 0.975 0.998 1.195043e-193\nNr4a2   9.607598e-193 -2.1841673 0.503 0.855 1.899518e-188\nRpl21   2.319987e-190 -0.6377144 0.967 0.998 4.586847e-186\nRpl9    1.249444e-187 -0.6824496 0.954 0.999 2.470276e-183\n\n\nThe output from the FindMarkers() function is a matrix containing a ranked list of differentially expressed genes listed by gene ID and associated statistics. We describe some of these columns below:\n\ngene: The gene symbol\np_val: The p-value not adjusted for multiple test corrections\navg_logFC: The average log-fold change between sample groups. Positive values indicate that the gene is more highly expressed ident.1.\n\npct.1: The percentage of cells where the gene is detected in ident.1 (cold7)\n\npct.2: The percentage of cells where the gene is detected on average in ident.2 (TN)\np_val_adj: The adjusted p-value, based on Bonferroni correction using all genes in the dataset, used to determine significance\n\n\n\n\n\n\n\nNote\n\n\n\nThese tests treat each cell as an independent replicate and ignore inherent correlations between cells originating from the same sample. This results in highly inflated p-values for each gene. Studies have been shown to find a large number of false positive associations with these results.\n\n\nWhen looking at the output, we suggest looking for markers with large differences in expression between pct.1 and pct.2 and larger fold changes. For instance if pct.1 = 0.90 and pct.2 = 0.80, it may not be as exciting of a marker. However, if pct.2 = 0.1 instead, the bigger difference would be more convincing. Also of interest is whether the majority of cells expressing the gene are in the group of interest. If pct.1 is low, such as 0.3, it may not be as interesting. Both of these are also possible parameters to include when running the function, as described above.\nThis is a great spot to pause and save your results!\n\nwrite.csv(dge_vsm, \"../results/findmarkers_vsm_cold7_vs_TN.csv\")"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#significant-genes",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#significant-genes",
    "title": "DE analysis using FindMarkers",
    "section": "Significant genes",
    "text": "Significant genes\nWe want to subset our results to show just our significant genes so we can begin visualizing and analyzing the results. To do this, we filter out rows based upon the p_val_adj column and subsetting only genes that meet our multiple testing-corrected significance threshold of 0.05.\n\n# Subset significant genes\ndge_vsm_sig &lt;- dge_vsm %&gt;% subset(p_val_adj &lt; 0.05)\ndge_vsm_sig %&gt;% head()\n\n                p_val avg_log2FC pct.1 pct.2     p_val_adj\nGm42418 4.492261e-223  1.8013603 0.999 0.986 8.881650e-219\nUbb     1.801612e-207 -0.8274973 0.982 0.999 3.561968e-203\nH3f3b   6.044423e-198 -0.9395566 0.975 0.998 1.195043e-193\nNr4a2   9.607598e-193 -2.1841673 0.503 0.855 1.899518e-188\nRpl21   2.319987e-190 -0.6377144 0.967 0.998 4.586847e-186\nRpl9    1.249444e-187 -0.6824496 0.954 0.999 2.470276e-183\n\n\n\nVolcano plot\nTo get a first look at the genes that are retained, we can generated a volcano plot using the EnhancedVolcano() function. This is a visualization that allows us to quickly see trends in the significant genes. The x-axis here represents the average log2-fold change value, showing the degree of difference between the two conditions. On the y-axis, we see our p_val_adj column represented after a negative log10 transformation is applied to better see the spread of the adjusted p-values.\nVolcano plots provide a great overview of which genes are up-regulated (positive on the x-axis) or down-regulated (negative on the x-axis).\n\n# Volcano plot\np_fm &lt;- EnhancedVolcano(dge_vsm_sig,\n        row.names(dge_vsm_sig),\n        x=\"avg_log2FC\",\n        y=\"p_val_adj\",\n       title=\"FindMarkers VSM cells\",\n       subtitle=\"TN vs cold7\")\n\np_fm\n\n\n\n\n\n\nViolin plots\nWhile looking at the overall trends in the data is a great starting point, we can also start looking at genes that have large differences between TN and cold7. To do this, we can take a look at the top 6 genes with the smallest p-values. We additionally disregard the ribsomal genes in this visualization step.\n\n# Get the gene names and get the first 6 values\n# Ignore ribosomal genes\ngenes &lt;- dge_vsm_sig %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;%\n  filter(!str_detect(gene, \"Rpl|Rps\")) %&gt;% \n  head(6)\ngenes &lt;- genes$gene\ngenes\n\n[1] \"Gm42418\" \"Ubb\"     \"H3f3b\"   \"Nr4a2\"   \"Cebpb\"   \"Fau\"    \n\n\nWith these genes selected, we can now being to visualize the distribution of expression across our two conditions using the VlnPlot() function.\n\n# Set Idents and draw Violin plots for top 6 genes\nIdents(seurat_vsm) &lt;- \"condition\"\nVlnPlot(seurat_vsm, genes, ncol=3, idents=c(\"TN\", \"cold7\"))\n\n\n\n\n\n\nUMAP plots\nWhen comparing two different conditions, we recommend creating a UMAP that clearly shows where the cells exist for each condition. To do so, we first need to get the UMAP coordinates for every cell of interest. When creating the scatterplot, the first thing we do is put a layer of light gray points that show the entire dataset to understand where all the cells fall. Then, we take the UMAP coordinates of the condition (TN or cold7 in our example) and plot those on top with a color to clearly indicate where those cells are located.\n\n\n\n\n\n\nNote\n\n\n\nThis sometimes works better on the non-integrated data, so you observe a true separation of cells by condition.\n\n\n\n# Grab the umap coordinates and condition information for each cell\ndf &lt;- FetchData(seurat_vsm, c(\"umap_1\", \"umap_2\", \"condition\"))\ndf_tn &lt;- df %&gt;% subset(condition == \"TN\")\ndf_cold7 &lt;- df %&gt;% subset(condition == \"cold7\")\n\n# Scatterplot of TN cells\np_tn &lt;- ggplot() +\n  geom_point(data=df, aes(x=umap_1, y=umap_2), color=\"lightgray\", alpha=0.5, size = 0.1) +\n  geom_point(data=df_tn, aes(x=umap_1, y=umap_2), color=\"#F8766D\", size = 0.1) +\n  theme_classic() +\n  ggtitle(\"VSM: TN cells\")\n\n# Scatterplot of cold7 cells\np_cold7 &lt;- ggplot() +\n  geom_point(data=df, aes(x=umap_1, y=umap_2), color=\"lightgray\", alpha=0.5, size = 0.1) +\n  geom_point(data=df_cold7, aes(x=umap_1, y=umap_2), color=\"#00B8E7\", size = 0.1) +\n  theme_classic() +\n  ggtitle(\"VSM: cold7 cells\")\n\n# TN and cold7 UMAPs side by side\np_tn + p_cold7\n\n\n\n\nThis allows us to better understand our results when we look at any follow-up information on our UMAP. For example, we can begin to look at the distribution of gene expression for each of the top 6 genes with a better understanding of where the cells for each condition lie:\n\nFeaturePlot(seurat_vsm, genes, ncol=3)"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#other-statistical-tests",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#other-statistical-tests",
    "title": "DE analysis using FindMarkers",
    "section": "Other statistical tests",
    "text": "Other statistical tests\nWhen we looked at the extra explanations for the FindMarkers() function, there was a parameter called test.use. By default, the method for calculating differentially expressed genes will be a Wilcoxon Rank Sum Test. This is a fairly simple statistical approach, and there a multitude of different algorithms that can be specified. These other options are documented on the FindMarkers() documentation page. For this workshop we want to highlight a few of these methods:\n\nWilcoxon Rank Sum Test\n\nOften described as the non-parametric version of the two-sample t-test.\nBeneficial because it can reduce the impact of outliers, which can skew the results of parametric testing.\nIt ranks the data and compares the sum of ranks within each group, to identify significant differences.\n\n\n\nDESeq2\n\nIdentifies differentially expressed genes between two groups of cells based on a model using DESeq2 which uses a negative binomial distribution (Love et al., 2014). More information on DESeq2 will be provided in an upcoming lesson in this workshop.\nThis test option does not support pre-filtering of genes based on average difference (or percent detection rate) between cell groups. However, genes may be pre-filtered based on their minimum detection rate (min.pct) across both cell groups.\n\n\n\n\n\n\n\nNote\n\n\n\nThe creators of the Seurat package no longer recommend using the FindMarkers() implementation of DESeq2.\n\n\n\n\nMAST\n\nImplements an approach that accounts for the stochastic dropout and characteristic bimodal expression distributions in which expression is either strongly non-zero or non-detectable.\n\nA two-part, generalized linear model for such bimodal data that parameterizes both of these features\n\n\nAlso allows for estimation and control of the “cellular detection rate” (CDR) while simultaneously estimating treatment effects. This addresses the fact that cells scale transcript copy number with cell volume.\nPermits the analysis of complex experiments, such as repeated single-cell measurements under various treatments or longitudinal sampling of single cells from multiple subjects with a variety of background characteristics (e.g., sex, age), because it can easily be extended to accommodate random effects.\n\n\nNOTE: Instead of using the FindMarkers() implementation, we recommend directly using the MAST algorithm from the package itself for the best results.\nIf you are interested in exploring code to run MAST on this dataset directly using the package, please see the script at the link below. We recommend including the sample in the model to improve results by taking into account biological variability. Please note that this is a computationally intensive calculation and may take a long time to run.\n\n\nClick here for code to run MAST on this dataset side-by-side\n\nNote that this R code below uses the MAST library. In order to run this you will need to first install the required packagea and then &gt; load the libraries.\n\nlibrary(Seurat)\nlibrary(dplyr)\nlibrary(SingleCellExperiment)\nlibrary(MAST)\n\n# Seurat to SingleCellExperiment\nDefaultAssay(seurat_vsm) &lt;- \"RNA\"\nsce &lt;- as.SingleCellExperiment(seurat_vsm)\n# Apply log transformation\nassay(sce, \"logcounts\") &lt;- log2(counts(sce) + 1)\n\n# Create new sce object (with only 'logcounts' matrix)\nsce_1 &lt;- SingleCellExperiment(assays = list(logcounts = assay(sce, \"logcounts\")))\ncolData(sce_1) &lt;- colData(sce)\n\n# Change to SingleCellAssay\nsca &lt;- SceToSingleCellAssay(sce_1)\n\n# Calculate number of genes expressed per cell and scale the value\ncdr2 &lt;- colSums(SummarizedExperiment::assay(sca) &gt; 0)\ncolData(sca)$cngeneson &lt;- scale(cdr2)\n\n# Takes a long time to calculate!\n# Here our model includes:\n\t# The number of genes expressed (ngeneson)\n\t# Experimental condition (condition)\n\t# Sample as a random variable ((1 | sample))\n\nzlmCond &lt;- zlm(~condition + cngeneson + (1 | sample), \n               sca, method=\"glmer\", ebayes=FALSE)\n\n# Only test the condition coefficient.\nsummaryCond &lt;- summary(zlmCond, doLRT='conditionTN') \n\n# Some data wranging of the results\nsummaryDt &lt;- summaryCond$datatable\nfcHurdle &lt;- merge(summaryDt[contrast=='conditionTN' & component=='H',.(primerid, `Pr(&gt;Chisq)`)], #hurdle P values\n                 summaryDt[contrast=='conditionTN' & component=='logFC', \n                           .(primerid, coef, ci.hi, ci.lo)], by='primerid') #logFC coefficients\n\nfcHurdle[,fdr:=p.adjust(`Pr(&gt;Chisq)`, 'fdr')]"
  },
  {
    "objectID": "lessons/schedule.html",
    "href": "lessons/schedule.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "lessons/schedule.html#pre-reading",
    "href": "lessons/schedule.html#pre-reading",
    "title": "",
    "section": "Pre-reading",
    "text": "Pre-reading\n\nIntroduction to scRNA-seq\nscRNA-seq: From sequence reads to count matrix\nscRNA-seq: From counts to clusters\nDownload this project"
  },
  {
    "objectID": "lessons/schedule.html#day-1",
    "href": "lessons/schedule.html#day-1",
    "title": "",
    "section": "Day 1",
    "text": "Day 1\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:30 - 09:45\nWorkshop introduction\nWill\n\n\n09:45 - 10:15\nPre-reading review and Q&A\nAll\n\n\n10:15 - 10:25\nBreak\n\n\n\n10:25 - 11:00\nProject setup and data exploration\nWill\n\n\n11:00 - 11:50\nDifferential expression analysis using FindMarkers()\nNoor\n\n\n11:50 - 12:00\nOverview of self-learning materials and homework submission\nWill\n\n\n\n\nBefore the next class:\nI. Please study the contents and work through all the code within the following lessons:\n\nAggregating counts by celltype using pseudobulk approach\n\n\nClick here for a preview of this lesson\n\n Forming pseudobulk samples is important to perform accurate differential expression analysis. Treating each cell as an independent replicate leads to underestimation of the variance and misleadingly small p-values. Working on the level of pseudobulk ensures reliable statistical tests because the samples correspond to the actual units of replication. In this lesson you will: - Aggregate counts for a given celltype - Demonstrate an efficent way to aggregate counts for multiple celltypes - Use the aggregated counts to create a DESeq2 object for downstream analysis \n\nDE analysis of pseudobulk data using DESeq2\n\n\nClick here for a preview of this lesson\n\n The next step is to take the DESeq2 object and run through the analysis workflow to identify differentially expressed genes. In this lesson you will: - Perform sample level QC\n- Evaluate gene-wise dispersions to evalute model fit - Extract results and understand the statistics generated\n\n\n\nSubmit your work:\n\n\nEach lesson above contains exercises; please go through each of them.\nSubmit your answers to the exercises using this Google form on the day before the next class.\n\n\n\nQuestions?\n\nIf you get stuck due to an error while running code in the lesson, email us"
  },
  {
    "objectID": "lessons/schedule.html#day-2",
    "href": "lessons/schedule.html#day-2",
    "title": "",
    "section": "Day 2",
    "text": "Day 2\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:30 - 10:00\nSelf-learning lessons discussion\nAll\n\n\n10:00 - 10:40\nVisualization of differentially expressed genes\nWill\n\n\n10:40 - 10:50\nBreak\n\n\n\n10:50 - 12:00\nComparison of results from different DE approaches\nNoor\n\n\n\n\nBefore the next class:\nI. Please study the contents and work through all the code within the following lessons: 1. Functional Analysis\n\n\nClick here for a preview of this lesson\n\nNow that we have significant genes, let’s gain some biological insight In this lesson, we will: - Discuss approaches for functional analysis - Use clusterProfiler to run over-representation analsyis and visualize results - Use clusterProfiler to run GSEA \n\n\nSubmit your work:\n\n\nEach lesson above contains exercises; please go through each of them.\nSubmit your answers to the exercises using this Google form on the day before the next class.\n\n\n\nQuestions?\n\nIf you get stuck due to an error while running code in the lesson, email us"
  },
  {
    "objectID": "lessons/schedule.html#day-3",
    "href": "lessons/schedule.html#day-3",
    "title": "",
    "section": "Day 3",
    "text": "Day 3\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:30 - 10:15\nSelf-learning lessons discussion\nAll\n\n\n10:15 - 11:15\nMethods for Differental Abundance\nNoor\n\n\n11:15 - 11:20\nBreak\n\n\n\n11:25 - 11:45\nDiscussion and Q&A\nAll\n\n\n11:45 - 12:00\nWrap-up\nWill"
  },
  {
    "objectID": "lessons/schedule.html#answer-keys",
    "href": "lessons/schedule.html#answer-keys",
    "title": "",
    "section": "Answer Keys",
    "text": "Answer Keys\n\nDay 1 exercises\nDay 2 exercises"
  },
  {
    "objectID": "lessons/schedule.html#resources",
    "href": "lessons/schedule.html#resources",
    "title": "",
    "section": "Resources",
    "text": "Resources"
  }
]