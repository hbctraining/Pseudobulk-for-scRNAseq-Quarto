[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "Code\n\n\n\n\nPseudobulk and related approaches for scRNA-seq analysis\n\n\n\nAudience\nComputational skills required\nDuration\n\n\n\n\nBiologists\nIntroduction to R\n3-session online workshop (~7.5 hours of trainer-led time)\n\n\n\n\nDescription\nThis repository has teaching materials for a hands-on workshop on Pseudobulk and related approaches for scRNA-seq analysis. After clustering cells as part of a single-cell RNA-seq experiment, investigators are often interested in carrying out a differential expression analysis between conditions within certain cell types. When the experimental design includes replicates with multiple conditions there is power in identifying differentially expressed genes using a pseudobulk approach. This workshop will:\n\nDiscuss various approaches for differential expression using single cell RNA-seq data\nPrepare single-cell RNA-seq raw count data for pseudobulk analysis\nPerform differential expression analysis on pseudobulk counts using DESeq2\nPresent approaches for evaluating differential proportions of cells between conditions\n\nWorking knowledge of R is required or completion of the Introduction to R workshop.\n\n\n\nNote for Trainers:\nPlease note that the schedule linked below assumes that learners will spend between 3-4 hours on reading through, and completing exercises from selected lessons between classes. The online component of the workshop focuses on more exercises and discussion/Q & A.\n\n\n\n\n\n\n\nNote\n\n\n\nThese materials were developed for a trainer-led workshop, but are also amenable to self-guided learning.\n\n\n\nLearning Objectives\n\nUnderstanding considerations for when to use different DGE algorithms on scRNA-seq data\nUsing FindMarkers to evaluate significantly DE genes\nAggregating single cell expression data into a pseudobulk counts matrix to run a DESeq2 workflow\nEvaluating expression patterns of differentially expressed genes at the pseudobulk and single cell level\nApplication of methods for evaluating differential proportions of cells between conditions\n\n\n\nLessons\n\nWorkshop schedule (trainer-led learning)\nSelf-learning\n\n\n\nInstallation Requirements\n\nApplications\nDownload the most recent versions of R and RStudio for your laptop:\n\nR (version 4.0.0 or above)\nRStudio\n\n\n\nPackages for R\n\nNote 1: Install the packages in the order listed below.\n\n\nNote 2:  All the package names listed below are case sensitive!\n\n\nNote 3: If you have a Mac, download and install this tool before intalling your packages: https://mac.r-project.org/tools/gfortran-12.2-universal.pkg\n\n\nNote 4: At any point (especially if you’ve used R/Bioconductor in the past), in the console R may ask you if you want to update any old packages by asking Update all/some/none? [a/s/n]:. If you see this, type “a” at the prompt and hit Enter to update any old packages. Updating packages can sometimes take quite a bit of time to run, so please account for that before you start with these installations.\n\n\nNote 5: If you see a message in your console along the lines of “binary version available but the source version is later”, followed by a question, “Do you want to install from sources the package which needs compilation? y/n”, type n for no, and hit enter.\n\n(1) Install the 8 packages listed below from Bioconductor using the the BiocManager::install() function.\n\nBiocManager::install(\"DESeq2\")\nBiocManager::install(\"EnhancedVolcano\")\nBiocManager::install(\"SingleCellExperiment\")\nBiocManager::install(\"miloR\")\nBiocManager::install(\"clusterProfiler\")\nBiocManager::install(\"org.Mm.eg.db\")\nBiocManager::install(\"sccomp\")\nBiocManager::install(\"speckle\")\n\nPlease install them one-by-one as follows:\n\nBiocManager::install(\"DESeq2\")\nBiocManager::install(\"EnhancedVolcano\")\n& so on ...\n\n(2) Install the 9 packages listed below from CRAN using the install.packages() function.\n\ninstall.packages(\"Seurat\")\ninstall.packages(\"tidyverse\")\ninstall.packages(\"pheatmap\")\ninstall.packages(\"RColorBrewer\")\ninstall.packages(\"cowplot\")\ninstall.packages(\"dplyr\")\ninstall.packages(\"ggalluvial\")\ninstall.packages(\"msigdbr\")\ninstall.packages(\"ggvenn\")\n\nPlease install them one-by-one as follows:\n\ninstall.packages(\"Seurat\")\ninstall.packages(\"tidyverse\")\ninstall.packages(\"pheatmap\")\n& so on ...\n\n(3) Finally, please check that all the packages were installed successfully by loading them one at a time using the library() function.\n\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(pheatmap)\nlibrary(RColorBrewer)\nlibrary(cowplot)\nlibrary(dplyr)\nlibrary(DESeq2)\nlibrary(EnhancedVolcano)\nlibrary(SingleCellExperiment)\nlibrary(miloR)\nlibrary(ggalluvial)\nlibrary(clusterProfiler)\nlibrary(org.Mm.eg.db)\nlibrary(msigdbr)\nlibrary(ggvenn)\nlibrary(sccomp)\nlibrary(speckle)\n\n(4) Once all packages have been loaded, run sessionInfo().\n\nsessionInfo()"
  },
  {
    "objectID": "lessons/04_pseudobulk_DE_analysis.html",
    "href": "lessons/04_pseudobulk_DE_analysis.html",
    "title": "Pseudobulk DESeq2 analysis",
    "section": "",
    "text": "Approximate time: 40 minutes"
  },
  {
    "objectID": "lessons/04_pseudobulk_DE_analysis.html#learning-objectives",
    "href": "lessons/04_pseudobulk_DE_analysis.html#learning-objectives",
    "title": "Pseudobulk DESeq2 analysis",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nApply methods for sample-level QC\nExplain the different steps involved in running DESeq()\nGenerating a table of differentially expressed genes"
  },
  {
    "objectID": "lessons/04_pseudobulk_DE_analysis.html#sample-level-qc",
    "href": "lessons/04_pseudobulk_DE_analysis.html#sample-level-qc",
    "title": "Pseudobulk DESeq2 analysis",
    "section": "Sample-level QC",
    "text": "Sample-level QC\nA useful initial step in an RNA-seq analysis is to assess overall similarity between samples:\n\nWhich samples are similar to each other? Which are different?\nDoes this fit the expectation from the experiment’s design?\nWhat are the major sources of variation in the dataset?\n\nTo explore the similarity of our samples, we will be performing quality checks using Principal Component Analysis (PCA) and a hierarchical clustering approach.\n\n\n\nSample-level QC allows us to see how well our replicates cluster together, and observe whether the experimental condition represents the major source of variation in the data. Performing sample-level QC can also help identify any sample outliers, which may need to be explored further to determine whether they need to be removed prior to DE analysis.\nIn this lesson, we will introduce to you two different unsupervised clustering methods for exploratory data analysis. When using unsupervised methods it is helpful to apply a normalization or transformation to the data to improve the distances/clustering for visualization, rather than using raw counts. DESeq2 uses median of ratios method for count normalization, which is typically used for plotting expression data downstream after DE analysis. DESeq2 also has the option to transform counts using a regularized log transform (rlog) or varaince stabilizing transform (vst) as these can moderate the variance across the mean, and improve the clustering. The transformation of raw count data is recommended for sample-level QC.\n\nPCA\nPrincipal Component Analysis (PCA) is a dimensionality reduction technique used to emphasize variation and bring out strong patterns in a dataset. Details regarding PCA are given in our prepared lesson linked here.\nWe can run the rlog() function from DESeq2 to normalize and rlog transform the raw counts. Then, we could use the plotPCA() function to plot the first two principal components. By default, the plotPCA() function uses the top 500 most variable genes to compute principal components, but this parameter can be adjusted. Unfortunately, the plotPCA() function doesn’t label the point, so we will use the returnData = TRUE option to create a dataframe that we can use to plot the PCA ourselves.\n\n# Transform counts for data visualization\nrld &lt;- rlog(dds, blind=TRUE)\n\n# Return PCA data as a dataframe\npca_data_condition &lt;- plotPCA(rld, intgroup=c(\"condition\"), returnData = TRUE) \n# Create a new column with the names cleaned up called names_parsed\npca_data_condition &lt;- pca_data_condition %&gt;% \n  mutate(name_parsed = gsub(\"VSM_|_TN|_cold7\", \"\", name))\n\n# Plot the PCA results\nggplot(pca_data_condition, aes(x = PC1, y = PC2, color = condition, label = name_parsed)) +\n  geom_point() + \n  geom_text_repel(vjust = 1.5, hjust = 0.5, show.legend = FALSE) +\n  theme_classic() +\n  xlab(paste0(\"PC1: \", round(attr(pca_data_condition, \"percentVar\")[1] * 100), \"% variance\")) +\n  ylab(paste0(\"PC2: \", round(attr(pca_data_condition, \"percentVar\")[2] * 100), \"% variance\")) \n\n\n\n\nIn this example, we see a nice separation between our samples on PC1 by our condition of interest. This suggests that our condition of interest is the largest source of variation in our dataset. There is also a reasonable amount of within group variation for both TN and cold7 samples, with one of the cold7 samples off on its own in the top right quadrant of the plot.\nWe can check whether the number of cells from which the aggregated counts were derived influences the separation of the samples in the PCA plot. This is particularly useful if you notice an outlier sample, which may be explained by its very low (or very large) cell count compared to others. Here, the number of cells does not appear to explain the outlier cold7 sample.\n\n# Return PCA data as a dataframe\npca_data_n_cells &lt;- plotPCA(rld, intgroup=c(\"n_cells\"), returnData = TRUE) \n# Create a new column with the names cleaned up called names_parsed\npca_data_n_cells &lt;- pca_data_n_cells %&gt;% \n  mutate(name_parsed = gsub(\"VSM_|_TN|_cold7\", \"\", name))\n\n# Plot the PCA results\nggplot(pca_data_n_cells, aes(x = PC1, y = PC2, color = n_cells, label = name_parsed)) +\n  geom_point() + \n  geom_text_repel(vjust = 1.5, hjust = 0.5, show.legend = FALSE) +\n  theme_classic() +\n  xlab(paste0(\"PC1: \", round(attr(pca_data_n_cells, \"percentVar\")[1] * 100), \"% variance\")) +\n  ylab(paste0(\"PC2: \", round(attr(pca_data_n_cells, \"percentVar\")[2] * 100), \"% variance\")) \n\n\n\n\n\n\nSample correlation\nSimilar to PCA, hierarchical clustering is another, complementary method for identifying strong patterns in a dataset and potential outliers. The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination.\nThe hierarchical tree can indicate which samples are more similar to each other based on the normalized gene expression values. The color blocks indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Additionally, we expect to see samples clustered similar to the groupings observed in a PCA plot.\n\n# Calculate sample correlation\nrld_mat &lt;- assay(rld)\nrld_cor &lt;- cor(rld_mat)\n\n# Change sample names to original values\n# For nicer plots\nrename_samples &lt;- bulk_vsm$sample\ncolnames(rld_cor) &lt;- str_replace_all(colnames(rld_cor), rename_samples)\nrownames(rld_cor) &lt;- str_replace_all(rownames(rld_cor), rename_samples)\n\n# Plot heatmap\nanno &lt;- bulk_vsm@meta.data %&gt;%\n            select(sample, condition) %&gt;% \n            remove_rownames() %&gt;% \n            column_to_rownames(\"sample\")\npheatmap(rld_cor, annotation_col=anno, annotation_row=anno)\n\n\n\n\nSince we detected no outliers by PCA or hierarchical clustering, nor do we have any additional sources of variation to regress, we can proceed with running the differential expression analysis.\n\n\n\n\n\n\nExercises\n\n\n\n\nUse the dds_APC object to compute the rlog transformed counts for the Pdgfr α+ APCs.\nCreate a PCA plot for the Pdgfr α+ APCs, coloring points by condition. Do samples segregate by condition? Is there more or less variability within group than observed with the VSM cells?\nEvaluate the sample similarity using a correlation heatmap. How does this compare with the trends observed in the PCA plot?"
  },
  {
    "objectID": "lessons/04_pseudobulk_DE_analysis.html#running-deseq2",
    "href": "lessons/04_pseudobulk_DE_analysis.html#running-deseq2",
    "title": "Pseudobulk DESeq2 analysis",
    "section": "Running DESeq2",
    "text": "Running DESeq2\nDifferential expression analysis with DESeq2 involves multiple steps as displayed in the flowchart below in blue. Briefly, DESeq2 will model the raw counts, using normalization factors (size factors) to account for differences in library depth. Then, it will estimate the gene-wise dispersions and shrink these estimates to generate more accurate estimates of dispersion to model the counts. Finally, DESeq2 will fit the negative binomial model and perform hypothesis testing using the Wald test or Likelihood Ratio test. All of these steps are explained in detail in our additional materials.\n\n\n\nAll of the steps described above are conveniently performed by running the single DESeq() function on the DESeq2 object (dds) we created earlier.\n\n# Run DESeq2 differential expression analysis\ndds &lt;- DESeq(dds)\n\nEverything from normalization to linear modeling was carried out by the use of a single function! This function will print out a message for the various steps it performs:\n\nModel fitting\nThe aggregated count data generated by RNA-seq exhibits overdispersion (variance &gt; mean) and the statistical distribution used to model the counts needs to account for this. As such, DESeq2 uses a negative binomial distribution to model the RNA-seq counts using the equation below:\n\n\n\nThe two parameters required are the size factor, and the gene-wise dispersion estimate; both of which can estimated from the observed data. Next, a generalized linear model (GLM) of the NB family is used to fit the data. Modeling is a mathematically formalized way to approximate how the data behaves given a set of parameters.\n\nSize factor is used to make count values from different samples comparable. This is necessary because different samples may have been sequenced to different depths. DESeq2 uses the median of ratios method for computing a size factor for each sample.\nDispersion models the within-group variability by describing how much the variance deviates from the mean. A dispersion of 1 would indicate that there is no deviance from the mean (i.e., mean = variance). A typical RNA-seq dataset will exhibit some amount of biological variability present across replicates and so we will always have dispersion values less than one.\n\n\n\n\n\nEffect on dispersion\n\n\n\n\nVariance increases\nDispersion increases\n\n\nMean expression increases\nDispersion decreases\n\n\n\nWe can check the fit of the model to our data by looking at the plot of gene-wise dispersion estimates and how they compare with mean expression.\n\nplotDispEsts(dds)\n\n\n\n\n\nIn this plot we have dispersion on the y-axis and mean normalized counts on the x-axis. Each black dot represents a gene and its initial maximum likelihood dispersion estimate (MLE) given the observed data. Simply looking at the trend of black dots, we observe an inverse relationship between mean and dispersion.\nThe red line represents a best fit curve to the gene-wise dispersion estimates. The idea behind fitting a curve to the data is that different genes will have different scales of biological variability, but, across all genes, there will be a distribution of reasonable estimates of dispersion corresponding to a given mean expression level.\nThe blue dots represent gene-wise dispersion estimates shrunken towards values predicted by the best fit curve. The amount of shrinkage will depend on how far the initial estimate is from the curve, and that distance will vary depending on total number of replicates.\n\nIf the initial estimate (black dot) is much lower than the fitted curve, then values are shrunken up towards the red line.\nDispersion estimates that are slightly above the curve are also shrunk toward the curve for better dispersion estimation.\nGenes with extremely high dispersion values are not shrunken (these genes are shown surrounded by blue circle). This is due to the likelihood that the gene does not follow the modeling assumptions and has higher variability than others for biological or technical reasons.\n\n\nBased on the trends observed in this curve, we can say that there is a good fit of the model to the data.\n\n\n\n\n\n\nExercises\n\n\n\n\nUsing the code below, run DESeq2 for the Pdgfr α+ APCs data. Following that draw the dispersion plot. Based on this plot do you think there is a reasonable fit to the model?\n\n\n# Run DESeq2 differential expression analysis for APC\ndds_APC &lt;- DESeq(dds_APC)\n\n\n\n\n\nSetting up contrasts\nNow we need to indicate which two sample classes we are interested in comparing, and we do this by specifying contrasts. The contrasts are used as input to the DESeq2 results() function to extract the desired results.\n\n\n\n\n\n\nNote\n\n\n\nIf we run the results() function without specifying contrast or name, it will return the comparison of the last level of the last variable in the design formula over the first level of this variable. If the order of levels are not specified, they are ordered alphabetically by DESeq2.\n\n\nWe can use the resultsNames() function to guide us on exact arguments to provide when extracting our results:\n\nresultsNames(dds)\n\n[1] \"Intercept\"             \"condition_cold7_vs_TN\"\n\n\nTo denote our comparison of interest, we need to specify the contrasted groups (here, cold7 vs. `TN).\n\ncontrast &lt;- c(\"condition\", \"cold7\", \"TN\")\n\nWe use this contrast to extract results:\n\n# Results of Wald test\nres &lt;- results(dds, \n               contrast=contrast,\n               alpha = 0.05)\n\n\n\nUnderstanding the results\nNow let’s take a look at what information is stored in the results:\n\nres %&gt;% head()\n\nlog2 fold change (MLE): condition cold7 vs TN \nWald test p-value: condition cold7 vs TN \nDataFrame with 6 rows and 6 columns\n        baseMean log2FoldChange     lfcSE      stat     pvalue      padj\n       &lt;numeric&gt;      &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;  &lt;numeric&gt; &lt;numeric&gt;\nXkr4     2.80496     -0.1625561  0.941450 -0.172666 0.86291417 0.9487990\nGm1992   0.00000             NA        NA        NA         NA        NA\nRp1      0.00000             NA        NA        NA         NA        NA\nSox17    6.30657      0.3843884  0.687326  0.559252 0.57599002 0.8147941\nMrpl15 267.61120     -0.0477763  0.175316 -0.272515 0.78522621 0.9185463\nLypla1 152.10108      0.5126464  0.158363  3.237154 0.00120728 0.0133217\n\n\n\n\n\n\n\n\nWhy do I see so many NA values in my results table?\n\n\n\nThe missing values represent genes that have undergone filtering as part of the DESeq() function. Prior to differential expression analysis it is beneficial to omit genes that have little or no chance of being detected as differentially expressed. This will increase the power to detect differentially expressed genes. DESeq2 does not physically remove any genes from the original counts matrix, and so all genes will be present in your results table. For more detailed information, take a look at this lesson on gene-level filtering.\n\n\nWe should have six columns of information reported for each gene (row). We can use the mcols() function to extract information on what the values stored in each column represent:\n\n# Get information on each column in results\nmcols(res, use.names=T)\n\nDataFrame with 6 rows and 2 columns\n                       type            description\n                &lt;character&gt;            &lt;character&gt;\nbaseMean       intermediate mean of normalized c..\nlog2FoldChange      results log2 fold change (ML..\nlfcSE               results standard error: cond..\nstat                results Wald statistic: cond..\npvalue              results Wald test p-value: c..\npadj                results   BH adjusted p-values\n\n\n\nbaseMean: The mean of normalized counts for all samples\nlog2FoldChange: The log2-fold change\nlfcSE: The standard error\nstat: The Wald statistic\npvalue: The Wald test p-value\npadj: The Benjamini–Hochberg adjusted p-value\n\nThe main statistics we use for filtering these results and identifying significant genes are: pvalue, padj, and log2FoldChange. The fold changes reported in the results table are calculated by:\n\nlog2 (normalized_counts_group1 / normalized_counts_group2)\n\nThe problem is, these fold change estimates are not entirely accurate as they do not account for the large dispersion we observe with low read counts. To address this, the log2 fold changes need to be adjusted. For example, a 5 fold change for a gene which has a low mean count (e.g., 10) is not equivalent to a similar fold change observed in genes with extremeley high count (e.g., &gt; 1000). To generate more accurate log2 fold change (LFC) estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include:\n\nLow counts\nHigh dispersion values\n\nDESeq2 uses the distribution of LFC estimates for all genes to generate a prior (black solid line) to shrink the original LFC estimates of each gene (colored solid line) towards more likely (lower) LFC estimates (colored dotted line). As shown in the figure below, there is stronger shrinkage observed for genes with little information or high dispersion (purple gene).\n\n\n\nIllustration taken from the DESeq2 paper.\n\n\n\n\n\n\nNote\n\n\n\nShrinking the log2 fold changes will not change the total number of genes that are identified as significantly differentially expressed at a given padj. The shrinkage of fold change is to help with downstream assessment of results. For example, if you wanted to subset your significant genes based on fold change for further evaluation, you may want to use shrunken values. Additionally, for functional analysis tools such as GSEA that require fold change values as input, you would want to provide shrunken values.\n\n\nHere, we use the apeglm method (Zhu et al., 2018) for shrinkage estimator calculations. Alternative options for shrinkage estimation and the papers to cite if you use them are further described in the DESeq2 vignette.\n\n# Shrink the log2 fold changes to be more appropriate using the apeglm method - should cite Zhu et al., 2018 (https://doi.org/10.1093/bioinformatics/bty895) when using this method\nres &lt;- lfcShrink(dds, \n                coef = \"condition_cold7_vs_TN\",\n                res=res,\n                type = \"apeglm\")\n\nIf you take a look at the results table now, you will find fold change values may differ for some genes.\nThis is a great spot to store the results of the comparison:\n\nres %&gt;%\n  data.frame() %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;%\n  write.csv(\"../results/deseq2_VSM_cold7_vs_TN.csv\", row.names=F, quote=F)\n\n\n\n\n\n\n\nExercises\n\n\n\n\nGenerate results for the Pdgfr α+ APCs and save it to a variable called res_APC. There is nothing to submit for this exercise, but please run the code as you will need res_APC for future exercises."
  },
  {
    "objectID": "lessons/08_differential_abundance.html",
    "href": "lessons/08_differential_abundance.html",
    "title": "Differential abundance of cells in scRNA-seq",
    "section": "",
    "text": "Describe current approaches for evaluating differences in cell proportions between groups\nRun cluster-based differential abundance analysis\nDistinguish between cluster-based and cluster-free methods for DA analysis"
  },
  {
    "objectID": "lessons/08_differential_abundance.html#learning-objectives",
    "href": "lessons/08_differential_abundance.html#learning-objectives",
    "title": "Differential abundance of cells in scRNA-seq",
    "section": "",
    "text": "Describe current approaches for evaluating differences in cell proportions between groups\nRun cluster-based differential abundance analysis\nDistinguish between cluster-based and cluster-free methods for DA analysis"
  },
  {
    "objectID": "lessons/08_differential_abundance.html#differential-abundance-of-celltypes",
    "href": "lessons/08_differential_abundance.html#differential-abundance-of-celltypes",
    "title": "Differential abundance of cells in scRNA-seq",
    "section": "Differential abundance of celltypes",
    "text": "Differential abundance of celltypes\nDifferential abundance (DA) analysis is a method used to identify celltypes with statistically significant changes in cell proportions between different biological conditions. The overall aim is to find sub-populations of cells in which the ratio of cells from the two conditions is significantly different from the ratios observed in the overall data. Methods for differential abundance have been successfully used in practice in both clinical and experimental settings. For example, these approaches highlighted an increased presence of granulocytes, monocytes, and B cells in fatal cases of COVID-19 (1).\nThe figure below illustrates the aims of a differential abundance analysis. The different celltypes have different abundances and we would like to have a robust statistical approach to determine with these differences are significant."
  },
  {
    "objectID": "lessons/08_differential_abundance.html#cluster-based-approaches-for-da",
    "href": "lessons/08_differential_abundance.html#cluster-based-approaches-for-da",
    "title": "Differential abundance of cells in scRNA-seq",
    "section": "Cluster-based approaches for DA",
    "text": "Cluster-based approaches for DA\nMethods which are dependent on having cells grouped into phenotypically similar cell populations, most classically aligning with specific cell types, are what we call cluster-based approaches. Many single cell RNA-seq data analysis workflows produce a result with annotated sub-populations, making these tools very easy to implement as a next step.\n\nPropellor method\nThe propellor method is a function that is part of the speckle R package, which uses cell level annotation information to calculate differential abundance estimates.\nHow does it work? * First, cell type proportions are calculated for each sample. This results in matrix of proportions where the rows are the cell types and the columns are the samples. An example of this heterogeneity across samples can be observed in the plot below (left). * The matrix is then transformed such that a linear modeling framework can be applied. * As can be seen in the plot below (right), the cell type proportions are over-dispersed compared to the variance estimated under a Binomial distribution. * To overcome this, two transformations are available: arcsin square root and logit * Linear modeling is applied using an empirical Bayesian framework, allowing information to be borrowed across cell types to stabilize the cell type-specific variance estimates * For two groups, moderated t-tests are implemented; * For more than two groups, the option is a moderated ANOVA test. * Finally, false discovery rates are calculated.\n\n\n\nImage source: Phipson B. et al, 2022\n\n\nRunning propellor\nLet’s make a R script to hold our analysis called Differential_abundance.R. We can provide the R script with this header:\n\n# September 2024\n# HBC single-cell RNA-seq DGE workshop\n# Single-cell RNA-seq analysis - Differential abundance analysis\n\nNext, we will need to load the required library:\n\n# BiocManager::install(\"speckle\")\n# devtools::install_github(\"MangiolaLaboratory/sccomp\")\n\n# Load libraries\nlibrary(tidyverse)\nlibrary(speckle)\nlibrary(sccomp)\n\nTo begin, we will create a subset of the Seurat data object in which we keep only TN and cold7 samples. We will also create an associated metadata dataframe will contain the celltype and sample ID for each cell.\n\n# Subset to keep only cells from TN and cold7\n# seurat &lt;- readRDS(\"data/BAT_GSE160585_final.rds\") # This dataset was loaded in at the beginning of the workshop\nseurat_sub &lt;- subset(seurat, subset = (condition %in% c(\"TN\", \"cold7\")))\n\n# Create metadata df and factor celltype\nmeta_sub &lt;- seurat_sub@meta.data\nmeta_sub$celltype &lt;- factor(meta_sub$celltype)\n\nLet’s take a quick look at what the raw counts of celltypes look like within our dataset. Just by eye it looks like there are differences between groups!\n\n## Check count numbers of cells\nmeta_sub$condition_sample &lt;- paste0(meta_sub$condition, \"_\", meta_sub$sample)\ntable(meta_sub$condition_sample, meta_sub$celltype)\n\n                 \n                  Adipo   AP   EC ECAP Lymph Pericyte Schwann  VSM VSM-AP\n  cold7_Sample_15    15   78   90   17    32       19      83  249     28\n  cold7_Sample_16    15   88   55   78     8        9      56  132     29\n  cold7_Sample_7     11   99  158   31    31      145      84  200     25\n  cold7_Sample_8      8  217  141   28    33      179     137  296     29\n  TN_Sample_1         5  548  472  258    28      128     161 2006    133\n  TN_Sample_10        0   59  174  276    20        9      27 1789    202\n  TN_Sample_2         1   33   72  150     3       12       8  221     34\n  TN_Sample_9         0   55   95  191    14       15      16  954     46\n\n\nTo determine which celltypes are significantly different across our groups, we use the propeller() fuction. After supplying the seurat object as an argument, we then specify the sample IDs, celltypes, and experimental conditions:\n\n# Run differential proportion analysis\npropres &lt;- propeller(seurat_sub, \n                     sample=seurat_sub$sample,\n                     clusters = seurat_sub$celltype,\n                     group = seurat_sub$condition)\n\n\n# Look at the results table\nView(propres)\n\n\n\n\nAs a final step, we run variance stablization and fit a linear model to our data to ultimately create a dataframe of celltype proportions in each sample.\n\nprops &lt;- getTransformedProps(meta_sub$celltype, \n                                 meta_sub$condition_sample, \n                                 transform=\"logit\")\n\nNow that was have the transformed proportions, we can visualize the distribution of celltypes per sample.\n\n# Add a condition value to the dataframe\nprops_df &lt;- props$Proportions %&gt;%\n  as.data.frame() %&gt;%\n  mutate(condition = str_split_i(sample, \"_\", 1))\n\n# Proportion of celltypes per sample\nggplot(props_df) +\n  geom_bar(aes(x=sample, y=Freq, fill=clusters), \n           stat=\"identity\", color=\"black\") +\n  theme_classic() +\n  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +\n  NoLegend()\n\n\n\n\nWe can even assess how the Frequency changes across TN and cold7 on average. As we have replicates we can also show the variability - with error bars representing the standard deviation.\n\n# Calculate average proportion and standard deviation\nprops_df_summary &lt;- props_df %&gt;%\n  group_by(clusters, condition) %&gt;% \n  summarise(mean = mean(Freq), sd = sd(Freq))\n\n# Create barplot of mean proportions\n# Add error bars = mean +/- sd\nggplot(props_df_summary, aes(x=clusters, y=mean, fill=condition)) + \n    geom_bar(stat=\"identity\", color=\"black\", \n             position=position_dodge()) +\n    geom_errorbar(aes(ymin=mean-sd, ymax=mean+sd), \n                  width=.2, position=position_dodge(.9)) +\n    theme_classic()\n\n\n\n\n\nExercise 1. Take a look at the results table propres. Which celltypes show a significant change in composition between TN and cold7? 2. Does this line up with what we observed in the counts table?\n\nKeep these answers in mind as we compare these propeller results against another differential composition method called sccomp.\n\n\nDifferential compostion analysis using sccomp\nWhile propellor and other approaches based on linear regression (i.e., scDC, diffcyt) transform the data to model data compositionality, they do not model the actual data count distribution. Modeling single-cell compositional data as counts is important as small datasets and rare cell types are characterized by a high noise-to-signal ratio, and modeling counts enables the down-weighting of small cell-group proportions compared to larger ones (Mangiola s. et al, 2023). The sccomp core algorithm is outlined in the grey-boxed panels of the figure below. Additional panels of the figure highlight other features of sccomp, some of which are described in this lesson; and others (i.e simulation, benchmarking) are described more deeply in the paper.\n\n\n\nHow does it work?\n\nFit the model onto the data, and estimate the coefficients. sccomp can model changes in composition and variability. Here we provide the formula ~ condition, indicating the cell-group variability is dependent on condition.\nOptionally, sccomp can identify outliers probabilistically based on the model fit, and exclude them from the estimation.\nHypothesis testing is performed by calculating the posterior probability of the composition and variability effects being larger than a specified fold-change threshold\n\nWhen only a few groups or samples are present it becomes challenging to estimate the mean–variability association. sccomp gains this prior knowledge from other datasets and incoporates it to stabilize estimates.\n\n\nThe code below will perform the step outlined above. The input is the subsetted Seurat object seurat_sub used in the previous section of this lesson.\n\n# Run the first three steps of sccomp\nsccomp_result &lt;- seurat_sub %&gt;% \n  sccomp_estimate( \n    formula_composition = ~ condition, \n    .sample =  sample, \n    .cell_group = celltype, \n    bimodal_mean_variability_association = TRUE,\n    cores = 1,\n    verbose = FALSE\n  ) %&gt;% \n  sccomp_remove_outliers(cores = 1, verbose = FALSE) %&gt;%  # Optional  \n  sccomp_test()\n\nRunning standalone generated quantities after 1 MCMC chain, with 1 thread(s) per chain...\n\nChain 1 finished in 0.0 seconds.\n\n\nRunning standalone generated quantities after 1 MCMC chain, with 1 thread(s) per chain...\n\nChain 1 finished in 0.0 seconds.\n\n\n\nNote: It is recommended to follow the instructions for installing sccomp from the GitHub page under the GitHub section. Some people may run into issues compiling cmdstanr/cmdstan. We have found that specific versions of operating systems require extra steps for this compilation.\nTherefore, the next few lines will be a demo. However, we will provide the results of the sccomp method near the end so you can load the output yourself.\n\nThe column of interest to us is the c_FDR, as it reports the false-discovery rate of the null hypothesis for a composition (c). At an FDR &lt; 0.05, all celltypes are significantly changing with the exception of EC and Pericytes. Additionally, some celltypes are marginally significant (i.e. Lymph). Each of the columns in the output dataframe are described in more detail on the sccomp documentation page.\n\n# Significant results FDR &lt; 0.05\nsccomp_result %&gt;% \n  dplyr::filter(factor == \"condition\") %&gt;% \n  dplyr::filter(c_FDR &lt; 0.05) %&gt;% \n  dplyr::select(celltype, c_FDR) %&gt;% \n  head()\n\n# A tibble: 6 × 2\n  celltype    c_FDR\n  &lt;chr&gt;       &lt;dbl&gt;\n1 AP       0.000812\n2 Adipo    0.0146  \n3 ECAP     0       \n4 Lymph    0.0284  \n5 Schwann  0       \n6 VSM      0       \n\n\nWe can view the fold changes and can see that for Lymph, while the fold change appears to be high, the composition levels within each group are on the lower end.\n\n# Fold change\nsccomp_result %&gt;% \n  sccomp_proportional_fold_change(\n    formula_composition = ~  condition,\n    from =  \"TN\", \n    to = \"cold7\"\n  )\n\nFinally, we can visualize the data using boxplots.\n\nThe blue boxplots represent the posterior predictive check; it is what the model predicts the data should look like. The black boxplots represent the observed data.\nIf the model is descriptively adequate for the data, the blue boxplots should roughly overlay the black boxplots.\nA box without coloring for both groups, indicates a celltype which was not significant (i.e. EC)\n\n\n# Boxplots\nsccomp_result %&gt;% \n  sccomp_boxplot(factor = \"condition\")\n\nRunning standalone generated quantities after 1 MCMC chain, with 1 thread(s) per chain...\n\nChain 1 finished in 0.0 seconds.\n\n\n\n\n\n\n\nComparing propeller and sccomp results\nIf we look at the significant results of each method side-by-side, we find there is concordance in the majority of the celltypes in which proportions of cells were significantly different between conditions. We also see that both methods report the endothelial cells (EC) are not changing in composition between TN and cold7. There is discrepancy in the Endothelial cell-derived progenitor cells (ECAP) and the VSM-derived adipocyte progenitor cells (VSM-AP), as propellor reports that these celltypes do not change in proportion. Looking at the underlying data for results identified by only one of the methods is not entirely convincing. Best practice may be to run both methods and compare results. The most conservative approach would be to take the intersection of the two methods.\n\nIf you were not able to get sccomp installed or had issues compiling cmdstanr/cmdstan, you can download the sccomp_result object by right-clicking and selecting “Save Link as…” from here. Place this within your data folder.\nUse the following command to read the RDS object into R:\nsccomp_result &lt;- readRDS(\"data/sccomp_result.RDS\")\n\n\n# Get significant celltypes from propellor\np_results &lt;- propres %&gt;%\n     dplyr::filter(FDR &lt; 0.05) %&gt;%\n     rownames()\n\n# Get significant celltypes from sccomp\ns_results &lt;- sccomp_result %&gt;% \n     dplyr::filter(factor == \"condition\") %&gt;% \n     dplyr::filter(c_FDR &lt; 0.05) %&gt;% \n     dplyr::select(celltype)\n\n# Look at overlapping celltypes\ns_results %&gt;% dplyr::filter(celltype %in% p_results)\n\n# A tibble: 5 × 1\n  celltype\n  &lt;chr&gt;   \n1 AP      \n2 Adipo   \n3 Lymph   \n4 Schwann \n5 VSM"
  },
  {
    "objectID": "lessons/08_differential_abundance.html#cluster-free-approaches",
    "href": "lessons/08_differential_abundance.html#cluster-free-approaches",
    "title": "Differential abundance of cells in scRNA-seq",
    "section": "Cluster-free approaches",
    "text": "Cluster-free approaches\nIn cases where the sub-populations most responsive to the biological state do not fall into well-defined separate clusters, it can be useful to have available methods where the celltype annotation is not a required input.\nSome good examples of this include:\n\nHaving sub-populations of celltypes that are differentially abundant between conditions and therefore may be distributed among several adjacent clusters or, alternatively, encompass only a part of a cluster.\nContinuous processes where no clear cluster structure exists, such as cell cycles or certain developmental programs.\n\nFor the above scenarios, differential abundance at a cluster-based approaches may miss the important molecular mechanisms that differentiate between the states.\n\nmiloR\nA good example of a tool that does not rely on the annotation of cells is miloR. This tool makes use of k-nearest neighbor (KNN) graphs, a common data structure that is embedded in many single-cell analyses (Dann E. et al, 2021.) This can particularly helpful if you have questions on the more subtle shifts within a certain cell population. The tool miloR allows you to look more deeply into smaller neighborhoods of cells by utilizing differential abundance testing on the k-nearest neighbor graph.\n\n\n\nImage source: Dann E. et al, 2021\nThe general method of this tool is to assign cells to neighborhoods based upon a latent space (typically PCA) and neighborhood graph. Ultimately, we generate a neighborhood by counts matrix. These counts are modelled with a negative bionomial generalized linear model, which is then put through hypothesis testing to identify significantally differentially abundant neighborhoods with associated fold change values.\nWhile we won’t apply the miloR methods to our dataset in class, we do have a lesson that walks you through the miloR workflow. Each step is outlined in detail along with the code on how to apply it in this dataset. Note that the result is not directly comparable to results generated from cluster-based approaches (which are at the celltype level) presented in this lesson, because in cluster-free approaches the data is presented at the neighborhood-level."
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html",
    "href": "lessons/01_setup_intro_dataset.html",
    "title": "Project Setup and Data Exploration",
    "section": "",
    "text": "Introduce the dataset and begin setup by loading data\nDescribe the process of going from count matrix to annotated clusters\nExplore distribution of cluster annotations"
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html#learning-objectives",
    "href": "lessons/01_setup_intro_dataset.html#learning-objectives",
    "title": "Project Setup and Data Exploration",
    "section": "",
    "text": "Introduce the dataset and begin setup by loading data\nDescribe the process of going from count matrix to annotated clusters\nExplore distribution of cluster annotations"
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html#introduction-to-the-dataset",
    "href": "lessons/01_setup_intro_dataset.html#introduction-to-the-dataset",
    "title": "Project Setup and Data Exploration",
    "section": "Introduction to the dataset",
    "text": "Introduction to the dataset\nFor this workshop, we will be using the single-cell RNA-seq dataset from Shamsi et al (2021). The primary focus of this study was to evaluate the changes in brown adipose tissue (BAT) at different temperatures.\nCells were isolated from stromal vascular fraction of brown adipose tissue. After removal of all hematopoietic lineage-positive cells, 24,498 non-hematopoietic cells were re-clustered and visualisation of the clusters using UMAP identified eight major non-immune cell types present in BAT. This unsupervised clustering of gene expression profiles also revealed heterogeneity within each cell type, illustrated by the presence of multiple distinct clusters for each cell type.\n\n\n\nThe mice used in this study were housed in 4 different temperature conditions: - TN: 30 °C for 1 week - RT: 22 °C - cold2: 5 °C for 2 days - cold7: 5 °C for 7 days\nThere are four replicates per condition, except cold2 which has 3 replicates. This experimental design allowed for adequate comparison of gene expression for each celltype between conditions. For this workshop, we will be using this clustered data set as a starting point to demonstrate various approaches for identifying differentially expressed genes in single cell RNA-seq data.\n\nRaw data\nThe processed dataset is available on GEO (GSE160585) and the raw data is available for download on SRA. We chose to download the filtered counts data and metadata files, and use those to create a Seurat object as our starting point. For more detailed information and code on how to create the object from the GEO files, please see this lesson.\n\n\nRelevant metadata\nIn addition to the counts matrix, we also need to collect information about the data; this is known as metadata. There is often a temptation to just start exploring the data, but it is not very meaningful if we know nothing about the samples that this data originated from.\nSome relevant metadata for our dataset is provided below:\n\nData were generated with the 10x chromium Single Cell 3′ version 3 reagent kit\nSequenced on the NovaSeq S2 flow cell (Illumina, 100 cycles)\nProcessed with Cell Ranger 3.0.1"
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html#set-up",
    "href": "lessons/01_setup_intro_dataset.html#set-up",
    "title": "Project Setup and Data Exploration",
    "section": "Set up",
    "text": "Set up\nFor this workshop, we will be working within an RStudio project. In order to follow along you should have downloaded the R project.\n\n\n\n\n\n\nTip\n\n\n\nIf you haven’t done this already, the project can be accessed using this link.\n\n\nOnce downloaded, you should see a file called Pseudobulk_workshop.zip on your computer (likely, in your Downloads folder).\n\nUnzip this file. It will result in a folder of the same name.\nMove the folder to the location on your computer where you would like to perform the analysis.\nOpen up the folder. The contents will look like the screenshot below.\nLocate the .Rproj file and double-click on it. This will open up RStudio with the “Pseudobulk_workshop” project loaded."
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html#project-organization",
    "href": "lessons/01_setup_intro_dataset.html#project-organization",
    "title": "Project Setup and Data Exploration",
    "section": "Project organization",
    "text": "Project organization\nOne of the most important parts of research that involves large amounts of data is how best to manage it. We tend to prioritize the analysis, but there are many other important aspects of data management that are often overlooked in the excitement to get a first look at new data. The HMS Data Management Working Group discusses in-depth some things to consider beyond the data creation and analysis.\nFor each experiment you work on and analyze data for, it is considered best practice to get organized by creating a planned storage space (directory structure). We will do that for our single-cell analysis.\nLook inside your project space and you will find that a directory structure has been set up for you:\nPseudobulk_workshop/\n├── data\n├── meta\n├── results\n└── figures\n\n\n\n\n\n\nNOTE FOR WINDOWS OS users\n\n\n\nWhen you open the project folder after unzipping, please check if you have a data folder with a subfolder also called data. If this is the case, please move all the files from the subfolder into the parent data folder."
  },
  {
    "objectID": "lessons/01_setup_intro_dataset.html#loading-single-cell-rna-seq-count-data",
    "href": "lessons/01_setup_intro_dataset.html#loading-single-cell-rna-seq-count-data",
    "title": "Project Setup and Data Exploration",
    "section": "Loading single-cell RNA-seq count data",
    "text": "Loading single-cell RNA-seq count data\nNext, let’s open a new Rscript file, and start with some comments to indicate what this file is going to contain:\n\n# September 2024\n# HBC Pseduobulk workshop\n\n# Single-cell RNA-seq analysis - metadata\n\nSave the Rscript as metadata.R. Your working directory should look something like this:\nA GIF demonstrating this step is shown below:\n\n\n\n\nLoading libraries\nNext, we can load the necessary libraries:\n\n# Load libraries\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(ggalluvial)\n\n\n\nLoad Seurat object\nWe generated this Seurat object using the files that were deposited to GEO. More details on how this Seurat object was generated are detailed in another lesson, where we provide more clarity on what parameters were used for normalization, integration, and clustering.\nLet’s begin by looking at what metadata is stored inside the Seurat object, paying close attention to sample identities and celltype annotations.\n\n# Load Seurat object\nseurat &lt;- readRDS(\"../data/BAT_GSE160585_final.rds\")\ncolnames(seurat@meta.data)\n\n [1] \"orig.ident\"             \"nCount_RNA\"             \"nFeature_RNA\"          \n [4] \"sample\"                 \"log10GenesPerUMI\"       \"mitoRatio\"             \n [7] \"condition\"              \"S.Score\"                \"G2M.Score\"             \n[10] \"Phase\"                  \"CC.Difference\"          \"nCount_SCT\"            \n[13] \"nFeature_SCT\"           \"integrated_snn_res.1.2\" \"celltype\"              \n[16] \"seurat_clusters\"       \n\n\nA nice way to observe patterns or trends in the data is to visualize it, especially when we are working with such a large number of cells!\n\n\nSample distribution\nRecall from the summary above that we have cells from four different conditions. We can use a barplot to show the number of cells for each replicate, coloring each sample by the temperature condition the mice were subjected to. This provides an overview of the number of cells we are working with for each replicate. This metric is important to bear in mind as we need to ensure that we have enough cells to run future analyses.\n\n# Number of cells per sample\nggplot(seurat@meta.data) +\n    geom_bar(aes(x=sample, fill=condition),\n             stat=\"count\", color=\"black\") +\n    theme_classic() +\n    theme(axis.text.x = element_text(angle=45, vjust=1, hjust=1)) +\n    labs(x=\"Sample name\", y=\"Number of cells\")\n\n\n\n\nWe can also see the distribution of cells across the UMAP for each replicate and sample. As this dataset has already been processed and integrated, we expect the cells to be integrated together - where there are no cells grouping together due to a batch effect (i.e sample). Instead the cells should be clustered together based upon gene expression similarity, which would ideally lead to celltypes being grouped together.\n\n# UMAPs of condition and sample\nDimPlot(seurat, group.by=c(\"sample\", \"condition\"))\n\n\n\n\n\n\nCelltype annotation\nIntially, cells were clustered at a range of resolutions. The authors chose a resolution 1.2 as it grouped cells adequately into the celltypes of interest.\n\n# UMAP clusters\np &lt;- DimPlot(seurat, group.by=\"seurat_clusters\") + NoLegend()\nLabelClusters(p, id = \"seurat_clusters\",  fontface = \"bold\", \n              size = 5, bg.colour = \"white\", bg.r = .2, force = 0)\n\n\n\n\nUsing these clusters and a variety of marker genes, the cells were annotated into 8 major non-immune cell types:\n\nPdgfra+ adipose progenitors (AP)\nVascular endothelial (ECAP, EC)\nLymphatic endothelial (Lymph)\nVascular smooth muscle cells (VSM)\nPericytes (Pericyte)\nAdipocytes (Adipo)\nMyelinating Schwann cells (Schwann)\nNon-myelinating Schwann cells (Schwann)\n\nNotable marker genes from the paper are represented here using the FeaturePlot() function. Here we can see that indeed the cells are grouping together based upon gene expression and celltype identities.\n\nFeaturePlot(seurat, c(\"Pdgfra\", \"Acta2\", \"Cdh5\", \n                      \"Lyve1\", \"Ucp1\", \"Mpz\"))\n\n\n\n\nThe mapping of cluster to celltypes is being represented here as an alluvial plot. This visualization provides a quick way to see which clusters have been annotated as which celltype.\n\n# Order clusters numerically\norder_cluster &lt;- unique(seurat$seurat_clusters) %&gt;% as.numeric() %&gt;% sort() %&gt;% as.character()\nseurat$seurat_clusters &lt;- factor(seurat$seurat_clusters, levels=order_cluster)\n\n# Map clusters to celltypes\nggplot(seurat@meta.data,\n        aes(axis1 = seurat_clusters,\n            axis2 = celltype,\n            fill = celltype)) +\n    geom_alluvium() +\n    geom_stratum() +\n    geom_text(stat = \"stratum\",\n        aes(label=after_stat(stratum))) +\n    theme_void() +\n    NoLegend() +\n    coord_flip()\n\n\n\n\nWith these updated celltype labels, we can see how they distribute on the UMAP.\n\n# UMAP celltype\nIdents(seurat) &lt;- \"celltype\"\np &lt;- DimPlot(seurat) + NoLegend()\nLabelClusters(p, id = \"ident\",  fontface = \"bold\", size = 4,\n              bg.colour = \"white\", bg.r = .2, force = 0)\n\n\n\n\nWe can even identify celltypes of interest based upon the proportion of cells in each experimental condition.\n\n# Barplot sample proportion by celltype \nggplot(seurat@meta.data) +\n    geom_bar(aes(x=celltype, fill=condition), \n                 position=position_fill(), color=\"black\") +\n    theme_classic() +\n    labs(x=\"Celltype\", y=\"Proportion of cells\")\n\n\n\n\nNow that we have a better understanding of what data we have available to us, we can begin our analysis!"
  },
  {
    "objectID": "lessons/07_functional_analysis_pseudobulk.html",
    "href": "lessons/07_functional_analysis_pseudobulk.html",
    "title": "Functional analysis of pseudobulk DE",
    "section": "",
    "text": "Approximate time: 40 minutes"
  },
  {
    "objectID": "lessons/07_functional_analysis_pseudobulk.html#learning-objectives",
    "href": "lessons/07_functional_analysis_pseudobulk.html#learning-objectives",
    "title": "Functional analysis of pseudobulk DE",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDescribe the theory of how functional enrichment tools yield statistically enriched functions or interactions\nDiscuss functional analysis using over-representation analysis and functional class scoring\nRun clusterProfiler on significant genes from pseudobulk DE analysis"
  },
  {
    "objectID": "lessons/07_functional_analysis_pseudobulk.html#functional-analysis-of-pseudobulk-differentially-expressed-genes",
    "href": "lessons/07_functional_analysis_pseudobulk.html#functional-analysis-of-pseudobulk-differentially-expressed-genes",
    "title": "Functional analysis of pseudobulk DE",
    "section": "Functional analysis of pseudobulk differentially expressed genes",
    "text": "Functional analysis of pseudobulk differentially expressed genes\nWhen it comes to functional analysis there are various analyses that can be done:\n\nDetermine whether there is enrichment of known biological functions, interactions, or pathways\nIdentify genes’ involvement in novel pathways or networks by grouping genes together based on similar trends\nUse global changes in gene expression by visualizing all genes being significantly up- or down-regulated in the context of external interaction data\n\nGenerally, for any differential expression analysis, it is useful to interpret the resulting gene lists using freely available web- and R-based tools. While tools for functional analysis span a wide variety of techniques, they can loosely be categorized into three main types: over-representation analysis, functional class scoring, and pathway topology [1].\n\n\n\nImage credit: Khatri et al, PloS Computational Biology\nIn this lesson, we will walk you through both an over-representation analysis and gene set enrichment analysis (GSEA) using an R Bioconductor package called clusterProfiler."
  },
  {
    "objectID": "lessons/07_functional_analysis_pseudobulk.html#over-representation-analysis",
    "href": "lessons/07_functional_analysis_pseudobulk.html#over-representation-analysis",
    "title": "Functional analysis of pseudobulk DE",
    "section": "Over-representation analysis",
    "text": "Over-representation analysis\nOver-representation analysis (ORA) is used to determine which a priori defined gene sets are more present (over-represented) in a subset of “interesting” genes than what would be expected by chance (Huang et al, 2009). Most genes in the genome have some pre-existing annotation associated with it, which has been compiled through a combination of manual curation and computational algorithms. There are a number of existing databases which define genes using a controlled vocabulary and then categorize genes into groups (gene sets) based on shared function, involvement in a pathway or presence in a specific cellular location, etc. A very commonly used gene annotataion resource is the Gene Ontology (GO) database, and is what we will use in our workflow.\nWe then use those categorizations to assess whether or not the enrichment observed amongst our DE gene results when compared to the larger universe of genes is significant.\n\n\n\n\nHypergeometric test\nThe statistical test that will determine whether something is actually over-represented is the Hypergeometric test.\nHypergeometric distribution is a probability distribution that describes the probability of some number of genes (k) being associated with “Functional category 1”, for all genes in our gene list (n=1000), compared to the number of genes (K) associated with “Functional category 1” from a population of all of the genes in entire genome (N=13,000) [2].\nThe calculation of probability of k successes follows the formula:\n\n\n\nThis test will result in a p-value that will be adjusted to consider multiple testing correction for each category tested.\n\n\nRunning ORA with clusterProfiler\nNow that we know more about what ORA is doing, let’s take our significant genes and see if there are any GO terms over-represented that align with what we expect to be happening in VSM cells with a change of temperature.\nIn the workshop so far, we have run differential expression analysis using two different approaches:\n\nUsing FindMarkers() to treat individual cells as replicates\nAggregating counts from all cells in a sample to run pseudobulk DE\n\nWe will take the results from the pseudobulk DE and run different functional analysis methods to obtain some biological insight.\nOpen up a new R script called functional-analysis.R and create a header indicating what the script will contain.\n\n# September 2024\n# HBC single-cell RNA-seq DGE workshop\n# Single-cell RNA-seq analysis - Functional analysis of pseudobulk results\n\nThe first thing we’ll do is load the required libraries:\n\n# Load libraries\nlibrary(tidyverse)\nlibrary(clusterProfiler)\nlibrary(org.Mm.eg.db)\nlibrary(msigdbr)\n\nNext, we will filter genes to remove any genes that have NA values in the padj column. These are genes that were not tested and so we do not want to consider them in our background set of genes. Once filtered, we create vectors containing our gene symbols for the background and query set of genes. We will query the up- and down-regulated gene sets separately, but note that you can also use the entire significant list as a query input.\n\n# Untested genes have padj = NA, so let's keep genes with padj != NA\ndge_deseq2_noNAs &lt;- filter(dge_deseq2, padj != \"NA\" )\n\n# Create background dataset for hypergeometric testing using all tested genes for significance in the results\nall_genes &lt;- as.character(dge_deseq2_noNAs$gene)\n\n# Extract significant results for up-regulated\nsigUp &lt;- dplyr::filter(dge_deseq2_noNAs, padj &lt; 0.05, log2FoldChange &gt; 0)\nsigUp_genes &lt;- as.character(sigUp$gene)\n\nFinally, we can perform the GO enrichment analysis and save the results:\n\n# Run GO enrichment analysis \negoUp &lt;- enrichGO(gene = sigUp_genes, \n                universe = all_genes,\n                keyType = \"SYMBOL\",\n                OrgDb = org.Mm.eg.db, \n                ont = \"BP\", \n                pAdjustMethod = \"BH\", \n                qvalueCutoff = 0.05, \n                readable = TRUE)\n\n\n\n\n\n\n\nNote\n\n\n\nNote 1: The different organisms with annotation databases available to use with for the OrgDb argument can be found here.\nNote 2: The keyType argument may be coded as keytype in different versions of clusterProfiler.\nNote 3: The ont argument can accept either “BP” (Biological Process), “MF” (Molecular Function), and “CC” (Cellular Component) subontologies, or “ALL” for all three.\n\n\n\n# Output results from GO analysis to a table\ncluster_summaryUp &lt;- data.frame(egoUp)\nwrite.csv(cluster_summaryUp, \"../results/clusterProfiler_VSM_TNvsCold7_upregulated.csv\")\n\n\n\n\n\n\n\nNote\n\n\n\nInstead of saving just the results summary from the egoUp object, it might also be beneficial to save the object itself. The save() function enables you to save it as a .rda file, e.g. save(egoUp, file=\"results/egoUp.rda\"). The statistics stored in the object can be used for downstream visualization.\n\n\n\n\nExploring results from over-representation analysis\nLet’s take a look at what terms are identified as over-represented in the genes up-regulated in cold conditions.\n\nView(cluster_summaryUp)\n\nIn the first few columns we see the GO identifier and the descriptive term name. In the next two columns that follow, we observe GeneRatio and BgRatio. These values allows us to compare the overlaps to the background.\n\nBgRatio: K/N\n\nThe total number of genes in the GO term gene set (K), divided by the total number of genes in universe (N)\n\nGeneRatio: k/n\n\nThe total number of genes in our sig DE gene set which overlap with the GO term gene set (k), divided by the total number of genes in our sig DE gene set that overlap with the universe gene set (n)\n\nFold Enrichment: (k/n)/(K/N)\n\nThis represents how many fold enriched is the GeneRatio compared to the BgRatio\n\n\nOther columns of interest are the p.adjust column (by which results are ordered by default), and the geneID column, which lists the gene symbols of the overlapping genes.\n\n\n\nWhen cold induces a response in vascular smooth muscle cells (VSMCs), the primary transcriptional change observed is an up-regulation of genes related to vasoconstriction. Vasoconstriction is when the muscles around your blood vessels tighten to make the space inside smaller. In our results table we see significant terms such as extracellular matrix organization and cell proliferation, which makes sense because the cold temperatures will lead to a shift towards a more contractile phenotype. We also observe up-regulation of genes involved in cell adhesion and tight junction formation, which are processes related to maintaining vascular integrity.\n\n\n\n\n\n\nExercises\n\n\n\n\nUsing the code above as a template, run the over-representation analysis on the significantly down-regulated genes from the pseudobulk analysis.\n\nHow many significant terms do you find?\nWhat are some of the prominent biological processes that are observed?\n\n\n\n\n\n\nVisualizing over-representation analysis results\nclusterProfiler has a variety of options for viewing the over-represented GO terms. We will explore the dotplot and the enrichment plot in this lesson.\nThe dotplot shows statistics associated with a user-selected top number of significant terms. The color of the dots represents the adjusted p-values for these terms and size of the dots corresponds to the total count of sig DE genes annotated with the GO term (count). This plot displays the top 20 GO terms ordered by gene ratio, not adjusted p-value.\n\n# Dotplot \ndotplot(egoUp, showCategory=20)\n\n\n\n\nTo save the figure, click on the Export button in the RStudio Plots tab and Save as PDF.... In the pop-up window, change: - Orientation: To Portrait - PDF size to 11 x 8 to give a figure of appropriate size for the text labels\nThe next plot is the enrichment GO plot, which shows the relationship between the top 50 most significantly enriched GO terms (padj) by grouping similar terms together. Before creating the plot, we will need to obtain the similarity between terms using the pairwise_termsim() function (instructions for emapplot). In the enrichment plot, the color represents the p-values relative to the other displayed terms (brighter red is more significant), and the size of the terms represents the number of genes that are significant from our list.\n\n# Add similarity matrix to the termsim slot of enrichment result\negoUp &lt;- enrichplot::pairwise_termsim(egoUp)\n\n# Enrichmap clusters the 50 most significant (by padj) GO terms to visualize relationships between terms\nemapplot(egoUp, showCategory = 50)\n\n\n\n\nTo save the figure, click on the Export button in the RStudio Plots tab and Save as PDF.... In the pop-up window, ensure that the Orientation is Portrait and change the PDF size to 11 x 8 to give the figure the appropriate size for the text labels."
  },
  {
    "objectID": "lessons/07_functional_analysis_pseudobulk.html#gene-set-enrichment-analysis-gsea",
    "href": "lessons/07_functional_analysis_pseudobulk.html#gene-set-enrichment-analysis-gsea",
    "title": "Functional analysis of pseudobulk DE",
    "section": "Gene Set Enrichment Analysis (GSEA)",
    "text": "Gene Set Enrichment Analysis (GSEA)\nWhile over-representation analysis is helpful and commonly used, it does require you to subset your gene list using an arbitrary threshold. There could very well be many genes that very narrowly miss this threshold and are therefore not considered in the functional analysis. To get around this there are there are functional class scoring (FCS) methods that can be helpful. For these methods the hypothesis is that although large changes in individual genes can have significant effects on pathways (and will be detected via ORA methods), weaker but coordinated changes in sets of functionally related genes (i.e., pathways) can also have significant effects. Thus, rather than setting a threshold to identify ‘significant genes’, all genes are considered in the analysis. The gene-level statistics from the dataset are aggregated to generate a single pathway-level statistic and statistical significance of each pathway is reported. This type of analysis can be particularly helpful if the differential expression analysis only outputs a small list of significant DE genes.\nA commonly used example of an FCS method is GSEA (Subramanium A. et al, 2005). Gene set enrichment analysis utilizes the gene-level statistics or log2-fold changes for all genes to look to see whether gene sets for particular biological pathways (e.g., derived from KEGG pathways, Gene Ontology terms, MSigDB, etc) are enriched among the large positive or negative fold changes.\n\n\n\nImage source: (Subramanium A. et al, 2005)\nThis image describes the theory of GSEA, with the ‘gene set S’ showing the metric used (in our case, ranked log2-fold changes) to determine enrichment of genes in the gene set. There are four main steps that are being performed:\n\nRank genes:\n\nGenes in a data set are ranked based on the given statistic, which in our case is the shrunken log2-fold changes.\n\nCalculate enrichment scores for each gene set\n\nThis score reflects how often genes in the set appear at the top or bottom of the ranked list.\nThe score is calculated by walking down the list of log2-fold changes and increasing the running-sum statistic every time a gene in the gene set is encountered and decreasing it when genes are not part of the gene set.\nIncrease/decrease is determined by magnitude of fold change.\n\nEstimate statistical significance\n\nA permutation test is used to calculate a null distribution for the enrichment score. This produces a p-value that represents the probability of observing a given enrichment score.\n\nAdjust for multiple hypothesis testing\n\nEnrichment scores are normalized for the size of each gene set and a false discovery rate is calculated to prevent false positives.\n\n\n\nRunning GSEA with MSigDB gene sets\nThe clusterProfiler package offers several functions to perform GSEA using different genes sets, including but not limited to GO, KEGG, and MSigDb. We will use the MSigDb gene sets in our example below. The Molecular Signatures Database (also known as MSigDB) is a collection of annotated gene sets. It contains 8 major collections for mouse, and for our analysis we will use C5, which contains the Gene Ontology gene sets. We can see how this aligns with our ORA result.\nTo run GSEA with the MSigDb gene sets, we will use the msigdbr R package which provides the MSigDB gene sets in tidy data format that can be used directly with clusterProfiler. The msigdbr package supports several species:\n\nmsigdbr_species()\n\n# A tibble: 20 × 2\n   species_name                    species_common_name                          \n   &lt;chr&gt;                           &lt;chr&gt;                                        \n 1 Anolis carolinensis             Carolina anole, green anole                  \n 2 Bos taurus                      bovine, cattle, cow, dairy cow, domestic cat…\n 3 Caenorhabditis elegans          &lt;NA&gt;                                         \n 4 Canis lupus familiaris          dog, dogs                                    \n 5 Danio rerio                     leopard danio, zebra danio, zebra fish, zebr…\n 6 Drosophila melanogaster         fruit fly                                    \n 7 Equus caballus                  domestic horse, equine, horse                \n 8 Felis catus                     cat, cats, domestic cat                      \n 9 Gallus gallus                   bantam, chicken, chickens, Gallus domesticus \n10 Homo sapiens                    human                                        \n11 Macaca mulatta                  rhesus macaque, rhesus macaques, Rhesus monk…\n12 Monodelphis domestica           gray short-tailed opossum                    \n13 Mus musculus                    house mouse, mouse                           \n14 Ornithorhynchus anatinus        duck-billed platypus, duckbill platypus, pla…\n15 Pan troglodytes                 chimpanzee                                   \n16 Rattus norvegicus               brown rat, Norway rat, rat, rats             \n17 Saccharomyces cerevisiae        baker's yeast, brewer's yeast, S. cerevisiae \n18 Schizosaccharomyces pombe 972h- &lt;NA&gt;                                         \n19 Sus scrofa                      pig, pigs, swine, wild boar                  \n20 Xenopus tropicalis              tropical clawed frog, western clawed frog    \n\n\nAnd you can see what gene sets are available:\n\nmsigdbr_collections()\n\n# A tibble: 23 × 3\n   gs_cat gs_subcat         num_genesets\n   &lt;chr&gt;  &lt;chr&gt;                    &lt;int&gt;\n 1 C1     \"\"                         299\n 2 C2     \"CGP\"                     3384\n 3 C2     \"CP\"                        29\n 4 C2     \"CP:BIOCARTA\"              292\n 5 C2     \"CP:KEGG\"                  186\n 6 C2     \"CP:PID\"                   196\n 7 C2     \"CP:REACTOME\"             1615\n 8 C2     \"CP:WIKIPATHWAYS\"          664\n 9 C3     \"MIR:MIRDB\"               2377\n10 C3     \"MIR:MIR_Legacy\"           221\n# ℹ 13 more rows\n\n\nFor our analysis, we will select the mouse C5 collection, which corresponds to GO gene sets. From the table, we only need two columns, Gene set name and the Gene symbol:\n\n# Use a specific collection; C5 GO signatures\nm_t2g &lt;- msigdbr(species = \"Mus musculus\", category = \"C5\") %&gt;%\n  dplyr::select(gs_name, gene_symbol)\n\nNow that we have our gene sets, we need to prepare the fold changes. GSEA will use the log2-fold changes obtained from the differential expression analysis for every gene to perform the analysis. We need to create an ordered and named vector for input to clusterProfiler:\n\n# Extract the foldchanges\nfoldchanges &lt;- dge_deseq2_noNAs$log2FoldChange\n\n# Name each fold change with the corresponding gene symbol\nnames(foldchanges) &lt;- dge_deseq2_noNAs$gene\n\n# Sort fold changes in decreasing order\nfoldchanges &lt;- sort(foldchanges, decreasing = TRUE)\n\nhead(foldchanges)\n\nD630033O11Rik        Elmod1         Apela         Wisp2          Gipr \n     7.588727      6.849549      5.983377      5.871715      5.155337 \n       Igfbp2 \n     5.035339 \n\n\nNow we are ready to run GSEA!\n\n# Run GSEA\nmsig_GSEA &lt;- GSEA(foldchanges, TERM2GENE = m_t2g, verbose = FALSE)\n\n# Extract the GSEA results\nmsigGSEA_results &lt;- msig_GSEA@result\n\n# Write results to file\nwrite.csv(msigGSEA_results, \"../results/gsea_msigdb_GO_genesets.csv\", quote=F)\n\n\n\n\n\n\n\nNote\n\n\n\nThe permutations are performed using random reordering, so every time we run the function we will get slightly different results. If we would like to use the same permutations every time we run a function, then we use the set.seed() function prior to running. The input to set.seed() can be any number.\n\n\nTake a look at the results table and reorder by NES (normalized enrichment score). What terms do you see positively enriched? Does this overlap with what we observed from ORA analysis?\n\n# Look at results ordered by NES\nmsigGSEA_results %&gt;% arrange(-NES) %&gt;% View()\n\n\n\n\n\nThe first few columns of the results table identify the gene set information.\nThe following columns include the associated statistics.\nThe last column will report which genes are part of the ‘core enrichment’. These are the genes associated with the pathway which contributed to the observed enrichment score (i.e., in the extremes of the ranking).\n\n\n\nGSEA visualization\nLet’s explore the GSEA plot of enrichment of one of the pathways in the ranked list using a built-in function from clusterProfiler. We can pick the top term GOMF_EXTRACELLULAR_MATRIX_STRUCTURAL_CONSTITUENT:\n\n# Plot the GSEA plot for a single enriched GO term\ngseaplot(msig_GSEA, geneSetID = 'GOMF_EXTRACELLULAR_MATRIX_STRUCTURAL_CONSTITUENT')\n\n\n\n\nIn this plot, the lines in plot represent the genes in the gene set GOMF_EXTRACELLULAR_MATRIX_STRUCTURAL_CONSTITUENT and where they occur among the log2-fold changes. The largest positive log2-fold changes are on the left-hand side of the plot, while the largest negative log2-fold changes are on the right. The top plot shows the magnitude of the log2-fold changes for each gene, while the bottom plot shows the running sum, with the enrichment score peaking at the red dotted line (which is among the positive log2-fold changes). This suggests the up-regulation of this function.\n\n\n\n\n\n\nExercises\n\n\n\nNow that we have run through functional analysis with the results from Pseudobulk DE, let’s see what results we derive from the DGE lists from our FindMarkers DE analysis.\n\nCreate a significant DE genes data frame from the FindMarkers results with an added fold change criteria to reduce the gene list size. You can do this by running the code below:\n\n\nsig_fc_dge &lt;- dge_vsm %&gt;% dplyr::filter(p_val_adj &lt; 0.05, abs(avg_log2FC) &gt; 1)\n\n\nUse this gene list to run an over-representation analysis. Be sure to separate genes into up- and down-regulated first. Also keep in mind that the background gene dataset is different than for the DESeq2 analysis. What are the top terms enriched among up-regulated genes? What are the top terms enriched among down-regulated genes?\nHow do these results compare with what we observed from the Pseudobulk DE functional analysis?"
  },
  {
    "objectID": "lessons/07_functional_analysis_pseudobulk.html#resources-for-functional-analysis",
    "href": "lessons/07_functional_analysis_pseudobulk.html#resources-for-functional-analysis",
    "title": "Functional analysis of pseudobulk DE",
    "section": "Resources for functional analysis",
    "text": "Resources for functional analysis\nIn this lesson we reviewed two different approaches for functional analysis and demonstrated the with the use of the clusterProfiler package. Note that there are numerous other options out there, including the use of web-based tools. Below we list a few tools that we are familiar with:\n\ng:Profiler - http://biit.cs.ut.ee/gprofiler/index.cgi\nDAVID - https://david.ncifcrf.gov\nclusterProfiler - http://bioconductor.org/packages/release/bioc/html/clusterProfiler.html\nReviGO (visualizing GO analysis, input is GO terms) - http://revigo.irb.hr/\nWGCNA - https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/ (no longer maintained)\nGSEA - http://software.broadinstitute.org/gsea/index.jsp\nSPIA - https://www.bioconductor.org/packages/release/bioc/html/SPIA.html\nGAGE/Pathview - http://www.bioconductor.org/packages/release/bioc/html/gage.html"
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html",
    "href": "lessons/03_pseudobulk_DESeq2.html",
    "title": "Set-up DESeq2 analysis",
    "section": "",
    "text": "Approximate time: 40 minutes"
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#learning-objectives",
    "href": "lessons/03_pseudobulk_DESeq2.html#learning-objectives",
    "title": "Set-up DESeq2 analysis",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nPrepare single-cell RNA-seq raw count data for pseudobulk differential expression analysis\nCreate a DESeq2 object for differential expression analysis on a specific cell type cluster"
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#pseudobulk-differential-expression-analysis",
    "href": "lessons/03_pseudobulk_DESeq2.html#pseudobulk-differential-expression-analysis",
    "title": "Set-up DESeq2 analysis",
    "section": "Pseudobulk differential expression analysis",
    "text": "Pseudobulk differential expression analysis\nIn the previous lesson we demonstrated how to perform a differential expression analysis using the FindMarkers() function in Seurat. The major limitation of this approach is that it treats each individual cell as a replicate, which inflates the p-value, resulting in many false positives. In this lesson we introduce you to the pseudobulk approach, in which cells belonging to a cluster are aggregated within each sample to create a gene by sample count matrix. This count matrix resembles the input we use for bulk RNA-seq, and we use a similar workflow to identify differentially expressed genes.\n\n\n\nForming pseudobulk samples is important to perform accurate differential expression analysis. Cells from the same sample/individual are more similar to each other than to cells from another individual. This means treating each cell as an independent sample leads to underestimation of the variance and misleadingly small p-values. Working on the level of pseudobulk ensures reliable statistical tests because the samples correspond to the units of replication.\nUsing a pseudobulk approach involves the following steps:\n\nSubsetting to the cells for the cell type(s) of interest to perform the DE analysis;\nExtracting the raw counts after QC filtering of cells to be used for the DE analysis;\nAggregating the counts and metadata to the sample level;\nPerforming the DE analysis (you need at least two biological replicates per condition to perform the analysis, but more replicates are recommended)."
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#setting-up",
    "href": "lessons/03_pseudobulk_DESeq2.html#setting-up",
    "title": "Set-up DESeq2 analysis",
    "section": "Setting up",
    "text": "Setting up\nLet’s begin by opening a new Rscript file, and include a commentheader line:\n\n# Single-cell RNA-seq analysis - Pseudobulk DE analysis with DESeq2\n\nSave the Rscript as DE_analysis_scrnaseq.R.\n\nLoad libraries\nNext, let’s load the libraries that we will be using for the analysis:\n\n# Load libraries\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(DESeq2)\nlibrary(pheatmap)\nlibrary(EnhancedVolcano)\nlibrary(RColorBrewer)\nlibrary(cowplot)\nlibrary(dplyr)\nlibrary(ggrepel)\n\n\n\nCreate metadata\nWe will want to create a dataframe with all of the sample-level metadata, this will be used during the aggregation step but also later with differential expression analysis.\n\n\n\n\n\n\nNote\n\n\n\nOther relevant metadata for a pseudobulk differential expression analysis include information about the individuals that will be contrasted (age, sex, clinical presentation, etc.). The more information you can collect about your study samples, the better!_\n\n\n\nmeta_columns &lt;- c(\"sample\", \"condition\")\nmeta &lt;- seurat@meta.data %&gt;%\n            select(meta_columns) %&gt;%\n            unique() %&gt;%\n            remove_rownames()\n\nmeta\n\n      sample condition\n1   Sample_1        TN\n2   Sample_2        TN\n3   Sample_9        TN\n4  Sample_10        TN\n5   Sample_3        RT\n6   Sample_4        RT\n7  Sample_11        RT\n8  Sample_12        RT\n9   Sample_6     cold2\n10 Sample_13     cold2\n11 Sample_14     cold2\n12  Sample_7     cold7\n13  Sample_8     cold7\n14 Sample_15     cold7\n15 Sample_16     cold7"
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#aggregate-counts-for-pseudobulk-analysis",
    "href": "lessons/03_pseudobulk_DESeq2.html#aggregate-counts-for-pseudobulk-analysis",
    "title": "Set-up DESeq2 analysis",
    "section": "Aggregate counts for pseudobulk analysis",
    "text": "Aggregate counts for pseudobulk analysis\nNow, before we transform our single-cell level dataset into one sample-level dataset per cell type (cluster), there are a few data wrangling steps involved. We know that we want to aggregate cells of a particular celltype and that we want to collapse them down by sample.\nTo aggregate the counts, we will use the AggregateExpression() function from Seurat. It will take as input a Seurat object, and return summed counts (“pseudobulk”) for each identity class. The default is to return a matrix with genes as rows, and identity classes as columns. We have set return.seurat to TRUE, which means rather than a matrix we will get an object of class Seurat. We have also specified which factors to aggregate on, using the group.by argument.\n\nbulk &lt;- AggregateExpression(\n            seurat,\n            return.seurat = TRUE,\n            assays = \"RNA\",\n            group.by = c(\"celltype\", \"sample\", \"condition\")\n)\nbulk\n\nAn object of class Seurat \n19771 features across 133 samples within 1 assay \nActive assay: RNA (19771 features, 0 variable features)\n 3 layers present: counts, data, scale.data\n\n\nNow our Seurat object has ‘cells’ that correspond to aggregated counts. We will see that the samples have the name “{celltype}_{sample}_{condition}” to show that we are grouping together counts based on sample, celltype, and condition. The metadata columns that were used as input are included in this new Seurat object as well.\n\n# each 'cell' is a sample-condition-celltype pseudobulk profile\ntail(Cells(bulk))\n\n[1] \"VSM-AP_Sample-3_RT\"    \"VSM-AP_Sample-4_RT\"    \"VSM-AP_Sample-6_cold2\"\n[4] \"VSM-AP_Sample-7_cold7\" \"VSM-AP_Sample-8_cold7\" \"VSM-AP_Sample-9_TN\"   \n\n\nNow would be the time to add to your metadata any other information you have on the samples. For example, adding the number of cells we aggregated on is useful information to include.\n\n# Number of cells by sample and celltype\nn_cells &lt;- seurat@meta.data %&gt;% \n              dplyr::count(sample, celltype) %&gt;% \n              rename(\"n\"=\"n_cells\")\nn_cells$sample &lt;- str_replace(n_cells$sample, \"_\", \"-\")\n\nmeta_bulk &lt;- left_join(bulk@meta.data, n_cells)\nrownames(meta_bulk) &lt;- meta_bulk$orig.ident\nbulk@meta.data &lt;- meta_bulk\n\n# Turn condition into a factor\nbulk$condition &lt;- factor(bulk$condition, levels=c(\"TN\", \"RT\", \"cold2\", \"cold7\"))\n\nbulk@meta.data %&gt;% head()\n\n                                 orig.ident celltype    sample condition\nAdipo_Sample-1_TN         Adipo_Sample-1_TN    Adipo  Sample-1        TN\nAdipo_Sample-11_RT       Adipo_Sample-11_RT    Adipo Sample-11        RT\nAdipo_Sample-12_RT       Adipo_Sample-12_RT    Adipo Sample-12        RT\nAdipo_Sample-13_cold2 Adipo_Sample-13_cold2    Adipo Sample-13     cold2\nAdipo_Sample-14_cold2 Adipo_Sample-14_cold2    Adipo Sample-14     cold2\nAdipo_Sample-15_cold7 Adipo_Sample-15_cold7    Adipo Sample-15     cold7\n                      n_cells\nAdipo_Sample-1_TN           5\nAdipo_Sample-11_RT          7\nAdipo_Sample-12_RT         43\nAdipo_Sample-13_cold2      28\nAdipo_Sample-14_cold2     491\nAdipo_Sample-15_cold7      15\n\n\nThe output of this aggregation is a sparse matrix and, when we take a quick look, we can see that it is a gene by celltype-sample matrix.\n\nbulk[[\"RNA\"]]$counts[1:5, 1:5]\n\n5 x 5 sparse Matrix of class \"dgCMatrix\"\n       Adipo_Sample-1_TN Adipo_Sample-11_RT Adipo_Sample-12_RT\nXkr4                   1                  .                  .\nGm1992                 .                  .                  .\nRp1                    .                  .                  .\nSox17                  .                  .                  .\nMrpl15                 5                 23                106\n       Adipo_Sample-13_cold2 Adipo_Sample-14_cold2\nXkr4                       .                     .\nGm1992                     .                     .\nRp1                        .                     .\nSox17                      .                     .\nMrpl15                   135                  2037\n\n\n\n\nClick here for alternative code for aggregating counts for multiple celltypes\n\nNote that this code uses a for loop. This will first subset out cells by celltype and then aggregate, creating a list of pseudobulked Seurat objects. First, we create a vector of unique celltypes in our data so that we can iterate over each one of them. \ncelltypes &lt;- sort(unique(seurat@meta.data[[\"celltype\"]]))\ncelltypes\n\n[1] \"Adipo\"    \"AP\"       \"EC\"       \"ECAP\"     \"Lymph\"    \"Pericyte\" \"Schwann\" \n[8] \"VSM\"      \"VSM-AP\"  \n\n\nNext, we want to store the aggregated, pseudobulked expression for each celltype as a list of Seurat objects. Therefore we are going to use the same steps we ran above with the AggregateExpression() function and adding the number of cells in each group as a metadata column. \npb_list &lt;- list()\nfor (ct in celltypes) {\n  \n  # Subset cells to one celltype\n  seurat_ct &lt;- subset(seurat, subset=(celltype == ct))\n  \n  # Aggregate to get pseudobulk\n  bulk_ct &lt;- AggregateExpression(\n              seurat_ct,\n              return.seurat = T,\n              assays = \"RNA\",\n              group.by = c(\"celltype\", \"sample\", \"condition\")\n            )\n  \n  # Add number of cells per sample\n  n_cells &lt;- seurat_ct@meta.data %&gt;% \n                dplyr::count(sample, celltype) %&gt;% \n                rename(\"n\"=\"n_cells\")\n  n_cells$sample &lt;- str_replace(n_cells$sample, \"_\", \"-\")\n  meta_bulk_ct &lt;- left_join(bulk_ct@meta.data, n_cells)\n  rownames(meta_bulk_ct) &lt;- meta_bulk_ct$orig.ident\n  bulk_ct@meta.data &lt;- meta_bulk_ct\n  \n  pb_list[[ct]] &lt;- bulk_ct\n  \n}"
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#differential-gene-expression-with-deseq2",
    "href": "lessons/03_pseudobulk_DESeq2.html#differential-gene-expression-with-deseq2",
    "title": "Set-up DESeq2 analysis",
    "section": "Differential gene expression with DESeq2",
    "text": "Differential gene expression with DESeq2\nWe will be using DESeq2 for the pseudobulk DE analysis, and the analysis steps with DESeq2 are shown in the flowchart below in green and blue. DESeq2 first normalizes the count data to account for differences in library sizes and RNA composition between samples. Then, we will use the normalized counts to make some plots for QC at the gene and sample level. The final step is to use the appropriate functions from the DESeq2 package to perform the differential expression analysis. We will go into each of these steps briefly, but additional details and helpful suggestions regarding DESeq2 can be found in our materials detailing the workflow for bulk RNA-seq analysis, as well as in the DESeq2 vignette."
  },
  {
    "objectID": "lessons/03_pseudobulk_DESeq2.html#creating-a-deseq2-object",
    "href": "lessons/03_pseudobulk_DESeq2.html#creating-a-deseq2-object",
    "title": "Set-up DESeq2 analysis",
    "section": "Creating a DESeq2 object",
    "text": "Creating a DESeq2 object\nFrom the pseudobulk Seurat object, we can extract the information required as the input to DESeq2. First, we need to decide which cell type we wish to focus on, and then retrieve the corresponding data from the object. We are going to look for differntially expressed genes between the TN and cold7 condition for the vascular smooth muscle (VSM) cells.\nWe use the subset() function to get the data we need:\n\nbulk_vsm &lt;- subset(bulk, subset= (celltype == \"VSM\") & \n                     (condition %in% c(\"TN\", \"cold7\")))\nbulk_vsm\n\nAn object of class Seurat \n19771 features across 8 samples within 1 assay \nActive assay: RNA (19771 features, 0 variable features)\n 3 layers present: counts, data, scale.data\n\n\n\nNumber of cells\nBefore moving on to a pseudobulk DGE analysis, it is important to identify how many cells we aggregated for each sample. We need to make sure that we have enough cells per sample after subsetting to one celltype. We can see that with the exception of one sample, the TN group has many cells and the cold7 samples have much fewer cells.\n\nggplot(bulk_vsm@meta.data, aes(x=sample, y=n_cells, fill=condition)) +\n    geom_bar(stat=\"identity\", color=\"black\") +\n    theme_classic() +\n    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +\n    labs(x=\"Sample name\", y=\"Number of cells\") +\n    geom_text(aes(label=n_cells), vjust=-0.5)\n\n\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nAnother cell type in this dataset that was particularly interesting to the authors were the Pdgfr α+ adipose progentior cells (APCs).\n\nSubset the bulk object to isolate only adipose progenitor cells for the TN and cold7 conditions. Assign it to variable called bulk_APC.\n\nHint: You may need to review celltypes to determine what this cell type is called in our data. You can find unique celltypes with the code:\n\ncelltypes &lt;- sort(unique(seurat@meta.data[[\"celltype\"]]))\n\n\nReminder: The abbreviations for the cell types can be found in the project set-up lesson.\n\n\nPlot the cell number distribution across samples. How do the numbers compare to VSM cells?\n\n\n\nNow we can create our DESeq2 object to prepare to run the DE analysis. We need to include the counts, metadata, and design formula for our comparison of interest. In the design formula we should also include any other columns in the metadata for which we want to regress out the variation (batch, sex, age, etc.). For this dataset, we only have our comparison of interest, which is stored as the condition in our metadata data frame.\nMore information about the DESeq2 workflow and design formulas can be found in our DESeq2 materials.\n\n# Get count matrix\ncluster_counts &lt;- FetchData(bulk_vsm, layer=\"counts\", vars=rownames(bulk_vsm))\n\n# Create DESeq2 object\n# transpose it to get genes as rows\ndds &lt;- DESeqDataSetFromMatrix(t(cluster_counts),\n                                colData = bulk_vsm@meta.data,\n                                design = ~ condition)\n\ndds\n\nclass: DESeqDataSet \ndim: 19771 8 \nmetadata(1): version\nassays(1): counts\nrownames(19771): Xkr4 Gm1992 ... CAAA01118383.1 CAAA01147332.1\nrowData names(0):\ncolnames(8): VSM_Sample-1_TN VSM_Sample-10_TN ... VSM_Sample-8_cold7\n  VSM_Sample-9_TN\ncolData names(5): orig.ident celltype sample condition n_cells\n\n\nNow that the DESeq2 object is created, we are ready to continue with our analysis!\n\n\n\n\n\n\nExercises\n\n\n\n\nUsing the code below, create a DESeq2 object for the Pdgfr α+ APCs data. There is nothing to submit for this exercise, but please run the code as you will need dds_APC for future exercises.\n\n\n# Get count matrix\nAPC_counts &lt;- FetchData(bulk_APC, layer=\"counts\", vars=rownames(bulk_APC))\n\n# Create DESeq2 object\n# transpose it to get genes as rows\ndds_APC &lt;- DESeqDataSetFromMatrix(t(APC_counts),\n                                colData = bulk_APC@meta.data,\n                                design = ~ condition)\n\ndds_APC"
  },
  {
    "objectID": "lessons/06_DE_comparisons.html",
    "href": "lessons/06_DE_comparisons.html",
    "title": "Comparing results from different DE approaches",
    "section": "",
    "text": "Approximate time: 70 minutes"
  },
  {
    "objectID": "lessons/06_DE_comparisons.html#learning-objectives",
    "href": "lessons/06_DE_comparisons.html#learning-objectives",
    "title": "Comparing results from different DE approaches",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nCompare and contrast results from DESeq2 and FindMarkers\nEvaluate possible contributing factors for differing results\nAssess the relationship between percentage of cells and DE significance"
  },
  {
    "objectID": "lessons/06_DE_comparisons.html#methods-for-differential-gene-expression-in-single-cell-rna-seq",
    "href": "lessons/06_DE_comparisons.html#methods-for-differential-gene-expression-in-single-cell-rna-seq",
    "title": "Comparing results from different DE approaches",
    "section": "Methods for differential gene expression in single cell RNA-seq",
    "text": "Methods for differential gene expression in single cell RNA-seq\nThere are many approaches for identifying differentially expressed genes in single cell RNA-seq data. While the literature presents various methods, there still remains a lack of consensus regarding the best way forward. Choosing the appropriate method for your data requires a basic understanding of the system and structure of the data. Some of the important questions to ask include:\n\nDo you have enough cells to aggregate and do a pseudobulk analysis? Do you have enough power to run statistical tests?\nAre there smaller cell states within a celltype that would be lost after aggregating with a pseudobulk approach?\nIs there a latent variable that should be included in a design model?\nAre there biological replicates that can be used to control for variability in the data?\n\n\n\n\n\n\n\nExercises\n\n\n\n\nTake a moment and answer the above questions for our VSM cells dataset.\n\n\n\nAnother important aspect to consider is the amount of computational resources it takes to calculate differentially expressed genes. The number of computer cores and length of time needed can be a limiting factor in determining which methods are viable options. The general trends are that pseudobulk methods will use the least computational resources, followed by naive methods, with mixed models requiring the most computational resources. That being said, the amount of computational power will scale directly with the number of cells and samples in the dataset. As single-cell datasets begin to reach in the millions of cells, the usage of High Performance Computing clusters is necessary to run even the simplest of calculations, let alone a differential gene expression analysis.\n\n\n\nImage credit: Nguyen et al, Nat Communications"
  },
  {
    "objectID": "lessons/06_DE_comparisons.html#comparing-results-from-different-dge-approaches",
    "href": "lessons/06_DE_comparisons.html#comparing-results-from-different-dge-approaches",
    "title": "Comparing results from different DE approaches",
    "section": "Comparing results from different DGE approaches",
    "text": "Comparing results from different DGE approaches\nSo far in this workshop, we have made use of the DESeq2 and FindMarkers algorithms to find differentially expressed genes between the TN and cold7 sample groups. In this lesson, we compare and contrast results and use visualizations to see the practical implications of the questions outlined in the beginning of the lesson.\nLet’s begin by creating a new Rscript called DE_comparison.R. At the top, add a commented header to indicate what this file is going to contain.\n\n# September 2024\n# HBC single-cell RNA-seq DGE workshop\n\n# Single-cell RNA-seq analysis - compare DGE results\n\nNext we will load the necessary libraries.\n\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(ggvenn)\nlibrary(pheatmap)\nlibrary(cowplot)\nlibrary(dplyr)\n\n\nVolcano plots\nIn the previous lessons we had created a volcano plot for the results of DESeq2 analysis and FindMarkers analysis. Let’s plot them again but this time side-by-side.\n\np_deseq2 + p_fm\n\n\n\n\n\n\nCan’t find these plot objects in your environment? Click here!\n\nNote that this R code below uses existing objects in your environment created in earlier lessons.\n# Volcano plot for Findmarkers results\np_fm &lt;- EnhancedVolcano(dge_vsm_sig,\n                        row.names(dge_vsm_sig),\n                        x=\"avg_log2FC\",\n                        y=\"p_val_adj\",\n                        title=\"FindMarkers VSM cells\",\n                        subtitle=\"TN vs cold7\")\n\n\n# Volcano plot for Pseudobulk results\np_deseq2 &lt;- EnhancedVolcano(sig_res,\n                        sig_res$gene,\n                        x=\"log2FoldChange\",\n                        y=\"padj\",\n                        title=\"DESeq2 VSM cells\",\n                        subtitle=\"TN vs cold7\")\n\n\n\nVisually, we see that there are more significant genes from the FindMarkers analysis. In order to best quantify the overlap and differences in methods, we can merge the results dataframes together. To do so, we will do some data wrangling to capture the most important information:\n\nMerge dataframes together\nChange column names to denote which method the results were generated from\nRemove unnecessary columns\nCreate a new column titled sig to identify if a gene was significant with an adjusted p-values &lt; 0.05 using these labels: FindMarkers, DESeq2, both, or Not Significant\n\nFirst, let us navigate to your environment and find the results objects from the the previous DESeq2 and FindMarkers lessons. You will need to find the following:\n\ndge_vsm - which contains the full result from the FindMarkers analysis\ndge_deseq2 - which contains the full result from the Pseudobulk analysis\n\n\n\n\n\n\n\nNote\n\n\n\nIf you are having trouble locating these objects, you can also read the files in from your working directory:\n\ndge_vsm &lt;- read.csv(\"../results/findmarkers_vsm_cold7_vs_TN.csv\")\n# Make sure there is a column called gene\ndge_vsm &lt;- dplyr::rename(dge_vsm, c(\"gene\"=\"X\"))\n\ndge_deseq2 &lt;- read.csv(\"../results/deseq2_VSM_cold7_vs_TN.csv\")\n\n\n\nNow, to the data wrangling to obtain our merged data frame:\n\n# Merge FindMarkers and DESeq2 results together\ndge &lt;- merge(dge_vsm, dge_deseq2, by=\"gene\")\n\n# Rename columns to easily understand where results came from\n# Remove columns we will not be using\ndge &lt;- dge %&gt;% \n  dplyr::rename(\"padj_fm\"=\"p_val_adj\",\n                \"padj_deseq2\"=\"padj\") %&gt;%\n  dplyr::rename(\"log2FC_fm\"=\"avg_log2FC\",\n                \"log2FC_deseq2\"=\"log2FoldChange\") %&gt;%\n  dplyr::select(-c(\"p_val\", \"baseMean\", \"lfcSE\", \"pvalue\"))\n\n# Create a column called sig\n# Identifies which methods a gene is significant in\ndge &lt;- mutate(dge, sig = case_when(\n                  ((padj_fm &lt; 0.05) & (padj_deseq2 &lt; 0.05)) ~ \"both\",\n                  (padj_fm &lt; 0.05) ~ \"FindMarkers\",\n                  (padj_deseq2 &lt; 0.05) ~ \"DESeq2\",\n                  ((padj_fm &gt; 0.05) & (padj_deseq2 &gt; 0.05)) ~ \"Not Significant\"))\n\ndge %&gt;% head()\n\n           gene log2FC_fm pct.1 pct.2      padj_fm log2FC_deseq2 padj_deseq2\n1 0610009B22Rik 0.4919641 0.238 0.138 6.745178e-07   0.178619741   0.5217744\n2 0610009O20Rik 0.3421628 0.259 0.152 2.299513e-06   0.021075663   0.9539047\n3 0610010K14Rik 0.3505411 0.163 0.088 1.093917e-05  -0.004912021   0.9819494\n4 0610012D04Rik 1.1632519 0.033 0.010 3.048507e-03   0.610698014   0.1015138\n5 0610012G03Rik 0.1019817 0.497 0.379 1.000000e+00   0.040974487   0.8935888\n6 0610030E20Rik 0.6008081 0.147 0.077 6.292494e-06   0.058878725   0.8641972\n              sig\n1     FindMarkers\n2     FindMarkers\n3     FindMarkers\n4     FindMarkers\n5 Not Significant\n6     FindMarkers\n\n\n\n\nVenn diagrams\nLet’s start with a quick look at overlapping genes between the two different approaches. We can represent the overlap of significant genes as a Venn diagram using ggvenn.\n\n# Subset to significant genes\nsig_fm &lt;- dge %&gt;% subset(sig %in% c(\"FindMarkers\", \"both\"))\nsig_deseq2 &lt;- dge %&gt;% subset(sig %in% c(\"DESeq2\", \"both\"))\n\n# Create list of significant gene names\nsig_genes &lt;- list(\n  FindMarkers = sig_fm$gene,\n  DESeq2 = sig_deseq2$gene\n)\n\n# Create Venn diagram\nggvenn(sig_genes, auto_scale = TRUE)\n\n\n\n\n\n\nBarplot\nNext, we can break that overlap into a barplot. The benefit of this visualization is that we can include the number of genes that were identified as not significant in both DESeq2 and FindMarkers. Here, we also categorize genes that are listed as NA, which is the result of DESeq2 filtering genes as was discussed earlier.\n\nggplot(dge, aes(x=sig, fill=sig)) +\n  geom_bar(stat=\"count\", color=\"black\") +\n  theme_classic() + NoLegend() +\n  theme(axis.text.x = element_text(angle=45, vjust=1, hjust=1)) +\n  labs(x=\"Significant\", y=\"Number of genes\") +\n  geom_label(vjust=-1, stat=\"count\", aes(label=format(after_stat(count))))\n\n\n\n\nUltimately, we find ~1,200 genes significant from both DESeq2 and FindMarkers. The DESeq2 significant list is considerably smaller and so the overlapping genes make up a good proportion of the total. To explore some of the similarities and differences, let’s look at specific genes that demonstrate each of the following cases:\n\nSignificant in only FindMarkers (Crebl2)\nSignificant in only DESeq2 (Hist1h1d)\nSignificant in both DESeq2 and FindMarkers (Tiparp)\n\n\n\nSignificant only in FindMarkers results\nFirst, let us take a look at the expression values for the gene Crebl2, which was significant from the FindMakers analysis, but not DESeq2. We can begin by looking at the statistical results (adjusted p-value and LFC) for this gene:\n\ndge %&gt;% subset(gene == \"Crebl2\")\n\n       gene log2FC_fm pct.1 pct.2    padj_fm log2FC_deseq2 padj_deseq2\n2046 Crebl2 0.1004054 0.164 0.102 0.03277797    0.06293984   0.8488375\n             sig\n2046 FindMarkers\n\n\nImmediately, we can see that there are fairly small percentage of cells that express the gene (pct.1 and pct.2) in both the cold7 and TN conditions. The LFC values are also on the lower end. To better understand what is happening at the expression level, we can visualize this gene at the single-cell level. We will use a violin plot and a ridge plot to evaluate the expression distribution for this gene in each condition.\n\np1 &lt;- VlnPlot(seurat_vsm, \"Crebl2\", idents=c(\"cold7\", \"TN\")) + NoLegend()\np2 &lt;- RidgePlot(seurat_vsm, \"Crebl2\", idents=c(\"cold7\", \"TN\")) + scale_x_log10()\np1 + p2\n\n\n\n\nWith the violin plot we can see that there is slightly higher expression in the TN condition. Similarly, the log10 scaled expression distribution represented as a ridge plot emphasizes that a small group of cells have similarly higher expression of Crebl2 across both conditions. By observing the expression at the single-cell level, we can possibly justify the significance call by FindMarkers.\nTo assess why DESeq2 did not evaluate Crebl2 as significantly different, we can take the normalized counts from the dds DESeq2 object to plot the expression at the pseudobulk level.\n\nplot_pb_count(dds, \"Crebl2\")\n\n\n\n\nAfter plotting expression for Crebl2, we can see that there is quite a bit of variability among the samples for both the TN and cold7 conditions. A qualitative assessment of the plot suggests that the within group varaiability is larger than the between group variability. This is a case where being unable to account for variability (as in FindMarkers) across replicates can skew the results.\n\n\nSignificant only in DESeq2\nNext let’s explore Hist1h1d, a gene that was only identified as significant from the DESeq2 results. We can repeat some of the visualizations to look at the underlying expression and see if it is a believable difference. We can start by pulling the result stats for Hist1h1d from our merged dataframe:\n\ndge %&gt;% subset(gene == \"Hist1h1d\")\n\n         gene log2FC_fm pct.1 pct.2    padj_fm log2FC_deseq2 padj_deseq2    sig\n4099 Hist1h1d  3.085607 0.013 0.002 0.08019887     0.2272345  0.04911827 DESeq2\n\n\nSimilar to before, we can see that very few cells are expressing this gene (even fewer than observed with Crebl2). The fold change is a bit higher than observed. Let’s take a look at the normalized expression values from pseudobulk to see if we can figure out why the DESeq2 algorithm identified this gene as significant.\n\nplot_pb_count(dds, \"Hist1h1d\")\n\n\n\n\nWe can see that among the cold7 replicates, there is one sample expressing considerably higher expression in Hist1h1d. This sample is driving the observed fold change. Next, we can assess the expression of Hist1h1d at the single-cell level. From the ridge plot, we see that the TN plot is unimodal, but with cold7 it is bimodal with a tiny little hump on the right hand side of the plot. This represents a handful of cells that are expressing Hist1h1d at higher levels.\n\np1 &lt;- VlnPlot(seurat_vsm, \"Hist1h1d\", idents=c(\"cold7\", \"TN\")) + NoLegend()\np2 &lt;- RidgePlot(seurat_vsm, \"Hist1h1d\", idents=c(\"cold7\", \"TN\")) + scale_x_log10()\np1 + p2\n\n\n\n\nUsing this example, we can see how in the process of pseudobulk aggregation, high expression in a small proportion of cells can drive the results. At the single-cell level, we are better able to observe the true distribution of expression across all cells and rule out cases where only a few cells are expressing Hist1h1d.\n\n\nHigh confidence genes: Significant in DESeq2 and FindMarkers\nA conservative approach for a DGE analysis, would be to use only the significant genes that are identified from both methods. As an example, we can take a look at the gene Tiparp which was significant in DESEq2 and FindMarkers. Again, let’s begin with a quick peek at the results file. Unlike the previous genes, the percentage of cells expressing this gene is on the higher end.\n\ndge %&gt;% subset(gene == \"Tiparp\")\n\n       gene log2FC_fm pct.1 pct.2     padj_fm log2FC_deseq2  padj_deseq2  sig\n8768 Tiparp -2.414068 0.393 0.742 2.1504e-141     -2.378904 3.917121e-34 both\n\n\nNext, we plot the normalized counts from pseudobulk aggregation. Here, we observe a clear difference in expression between groups. While there is some observed variability within the TN group, it is small compared to the varibility between groups. For this gene, it is clear why it was identified as significant.\n\nplot_pb_count(dds, \"Tiparp\")\n\n\n\n\nNow, let’s take a look at the expression values at the single cell level. Within the violin plot, we see there is a large distribution of cells in the TN group that show increased expression. The ridge plot displays a lower amplitude peak at the low end of expression and broad range across the higher end of expression. This suggests that while a small subset of cells exhibit low expression, a large majority express Tiparp at higher levels.\n\np1 &lt;- VlnPlot(seurat_vsm, \"Tiparp\", idents=c(\"cold7\", \"TN\")) + NoLegend()\np2 &lt;- RidgePlot(seurat_vsm, \"Tiparp\", idents=c(\"cold7\", \"TN\"))\np1 + p2"
  },
  {
    "objectID": "lessons/06_DE_comparisons.html#effect-of-percentage-of-cells-on-dge",
    "href": "lessons/06_DE_comparisons.html#effect-of-percentage-of-cells-on-dge",
    "title": "Comparing results from different DE approaches",
    "section": "Effect of Percentage of cells on DGE",
    "text": "Effect of Percentage of cells on DGE\nFrom the three examples provided above we observe a difference in the percentage of cells in which the gene is expressed. However, we handpicked the examples so it is not reasonable to jump to any conclusions about correlations between signifncance and percentage of cells. Since we have the data, we can plot it and assess if there is any observable trends.\nLet’s start by filtering our data to keep only the genes that are significant in one or both of the methods:\n\n# Remove non-significant genes\ndge_sig &lt;- dge %&gt;% subset(sig != \"Not Significant\")\n\nNow, we’ll use that data to generate a scatter plot of the fold changes from FindMarkers on the y-axis and DESeq2 fold changes on the x-axis. Each data point represents a gene, and it is colored based on the percentage on cells expressed in TN (pct.1, right plot) or cold 7 (pct.2 left plot). We see a smear of light blue on the diagonal, which are the cells with the highest percentage of cells.\n\npct_1 &lt;- ggplot(dge_sig %&gt;% arrange(pct.1), \n                aes(x=log2FC_deseq2, y=log2FC_fm, color=pct.1)) +\n          geom_point() +\n          labs(x=\"DESeq2 LFC\", y=\"FindMarkers LFC\", title=\"Percentage TN\") +\n          theme_classic()\n\npct_2 &lt;- ggplot(dge_sig %&gt;% arrange(pct.2), \n                aes(x=log2FC_deseq2, y=log2FC_fm, color=pct.2)) +\n  geom_point() +\n  labs(x=\"DESeq2 LFC\", y=\"FindMarkers LFC\", title=\"Percentage cold7\") +\n  theme_classic()\n\npct_1 + pct_2\n\n\n\n\nNow to really see if the percentage of cells is contributing to likelihood of being significant in both methods we need to color the data points. Let’s place these plots side-by-side:\n\n# Color points by significance method\npct_3 &lt;- ggplot(dge_sig %&gt;% arrange(pct.1), \n                aes(x=log2FC_deseq2, y=log2FC_fm, color=sig)) +\n  geom_point() +\n  labs(x=\"DESeq2 LFC\", y=\"FindMarkers LFC\", title=\"Percentage TN\") +\n  theme_classic()\n\npct_1 + pct_3\n\n\n\n\nThere is a smear of pink dots in the plot which line up pretty well with the smear of light blue, showing that a large proportion of the genes identified as significant by both methods are those which are expressed in a large percentage of cells. However, this is not the the rule as you can see a number of pink points that deviate from the diagonal - these are genes that exhibit fairly large changes and are significant in both methods yet are expressed in a small percentage of cells.\nFinally, let’s make a heatmap of expression values using the normalized expression values from Pseudobulk and see if we can find any global patterns among the genes.\n\n# Extract normalized expression for significant genes from the samples\nnormalized_counts &lt;- counts(dds, normalized=T) %&gt;% as.data.frame()\nnorm_sig &lt;- normalized_counts %&gt;% \n  dplyr::filter(row.names(normalized_counts) %in% dge_sig$gene)\n\n# Create dataframe annotating rows (genes) and columns (samples)\nanno_col &lt;- colData(dds) %&gt;% data.frame() %&gt;% dplyr::select(condition)\nanno_row &lt;- dge_sig %&gt;% \n              dplyr::select(gene, sig, pct.1, pct.2) %&gt;% \n              remove_rownames() %&gt;% \n              column_to_rownames(\"gene\")\n\n# Create heatmap\npheatmap(norm_sig, \n         show_rownames=FALSE,\n         show_colnames=FALSE,\n         annotation_row=anno_row, \n         annotation_col=anno_col, \n         scale=\"row\")\n\n\n\n\nThrough this visualization, we can see that there is a a clustering of genes that are found significant by DESeq2 and FindMarkers, with some of the ‘both’ genes scattered. Most of the DESeq2 genes have a high percentage of cells expressing them, suggesting this drives the results observed with Pseudobulk."
  },
  {
    "objectID": "lessons/05_pseudobulk_DE_visualizations.html",
    "href": "lessons/05_pseudobulk_DE_visualizations.html",
    "title": "Pseudobulk visualization",
    "section": "",
    "text": "Approximate time: 40 minutes"
  },
  {
    "objectID": "lessons/05_pseudobulk_DE_visualizations.html#learning-objectives",
    "href": "lessons/05_pseudobulk_DE_visualizations.html#learning-objectives",
    "title": "Pseudobulk visualization",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nExplore visualization methods for interrogating significant genes from DESeq2\nEvaluate top genes to better understand the changes between conditions"
  },
  {
    "objectID": "lessons/05_pseudobulk_DE_visualizations.html#visualization-of-differentially-expressed-genes",
    "href": "lessons/05_pseudobulk_DE_visualizations.html#visualization-of-differentially-expressed-genes",
    "title": "Pseudobulk visualization",
    "section": "Visualization of differentially expressed genes",
    "text": "Visualization of differentially expressed genes\nVisualization is a key step for understanding the results of our analysis. In particular, we want to focus on the significant genes that are differentially expressed between the two conditions of interest. In doing so, we can better understand patterns in gene expression and identify any outlier genes that may bring up further questions in a downstream analysis. Additionally, these visualizations are a great way to globally evaluate the changes brought about due to an experimental condition.\n\nIdentify significant genes\nNow that we have a table of genes with their associated adjusted p-values and log-fold change scores, we need to filter the results. We are only interested in significantly differentially expressed genes that pass an adjusted p-value threshold of 0.05.\n\n# Set thresholds\npadj.cutoff &lt;- 0.05\n\n# Turn the results object into a tibble for use with tidyverse functions\ndge_deseq2 &lt;- res %&gt;%\n            data.frame() %&gt;%\n            as_tibble()\n\n# Subset the significant results\nsig_res &lt;- dplyr::filter(dge_deseq2, \n        padj &lt; padj.cutoff)\n\n# Look at top sig genes\nsig_res %&gt;% head()\n\n# A tibble: 6 × 6\n  gene   baseMean log2FoldChange lfcSE        pvalue        padj\n  &lt;chr&gt;     &lt;dbl&gt;          &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;       &lt;dbl&gt;\n1 Lypla1   152.            0.448 0.160 0.00121       0.0133     \n2 Rrs1      68.3          -0.479 0.221 0.00560       0.0442     \n3 Prex2      9.82          2.24  0.578 0.00000500    0.000131   \n4 Sulf1     90.8           1.39  0.259 0.00000000531 0.000000295\n5 Rpl7    3814.           -0.430 0.115 0.0000468     0.000906   \n6 Mcm3      19.9           1.20  0.494 0.000682      0.00835    \n\n\nWe will take these results and use them as input to a few different visualization techniques to explore the changes in gene expression.\n\n\nVolcano plot\nTo get a first look at the significant genes compared to all genes tested, we can generated a volcano plot using the EnhancedVolcano() function. This is a visualization that allows us to quickly see trends in the significant genes. The x-axis here represents the average log2-fold change value, showing the degree of difference between the two conditions. On the y-axis, we see our adjusted p-value to which a negative log10 transformation is applied to better see the spread of our p-values.\nVolcano plots show us a great overview of which genes are up-regulated (positive on the x-axis) or down-regulated (negative on the x-axis).\n\np_deseq2 &lt;- EnhancedVolcano(sig_res,\n        sig_res$gene,\n        x=\"log2FoldChange\",\n        y=\"padj\",\n        title=\"DESeq2 VSM cells\",\n        subtitle=\"TN vs cold7\")\nprint(p_deseq2)\n\n\n\n\n\n\nHeatmap of differentially expressed genes\nAnother way to look at global patterns of gene expression is to take our normalized expression matrix for our significant genes and generate a heatmap. The rows correspond to significant genes, columns are samples, and each value is the normalized expression from the pseudobulk aggregation.\nUsing the pheatmap() function, we can also cluster samples and genes together based upon their similarity. From the heatmap below we can clearly see that samples are clustering together based upon which experimental condition they belong to (TN and cold7). Similarly, the genes are being grouped together based upon their expression values, where we can see which genes are up- and down-regulated in each condition.\n\n# Extract normalized expression for significant genes from the samples\nnormalized_counts &lt;- counts(dds, normalized=TRUE) %&gt;% as.data.frame()\nnorm_sig &lt;- normalized_counts %&gt;% \n              dplyr::filter(row.names(normalized_counts) %in% sig_res$gene)\n\n# Set a color palette\nheat_colors &lt;- brewer.pal(6, \"YlOrRd\")\n\n# Run pheatmap using the metadata data frame for the annotation\nanno &lt;- colData(dds) %&gt;% \n            as.data.frame() %&gt;% \n            select(condition, celltype)\npheatmap(norm_sig,\n    color = heat_colors,\n    cluster_rows = TRUE,\n    show_rownames = FALSE,\n    annotation = anno,\n    border_color = NA,\n    fontsize = 10,\n    scale = \"row\", \n    fontsize_row = 10, \n    height = 20)\n\n\n\n\n\n\nTop 6 genes\nIt is important to take a look at some of the top genes that show up. Alternatively, you could choose to use this plot to explore some of your candidate genes where you anticipated changes in gene expression between groups. This is a great way to evaluate why these genes showed up in the results.\nRather than just taking the top genes based on adjusted p-value, we can apply a fold change threshold. In our example below, we are using abs(log2FoldChange) &gt; 0.6 which translates to a ~50% increase or decrease in gene expression as additional criteria for subsetting.\n\ngenes &lt;- sig_res %&gt;% \n            arrange(padj) %&gt;% \n            subset(abs(log2FoldChange) &gt; 0.6) %&gt;% \n            head(6)\ngenes &lt;- genes$gene\ngenes\n\n[1] \"Rgs5\"  \"Mt1\"   \"Emd\"   \"Nr4a2\" \"Cwc25\" \"Cebpb\"\n\n\nNow that we have identified the significant genes that we will look at, we can use a scatterplot to look at the expression values for each sample in both groups. This plot is also a good sanity check to make sure that we are interpreting our fold change values correctly, as well.\nEach point represents a sample with the y-axis representing the normalized expression. Ideally we should see a clear shift in expression between our two conditions. As this is a helpful metric for assessing the pseudobulk results, we will create a function to make repeated use of this type of visualization.\n\n# pseudobulk scatterpot of normalized expression\nplot_pb_count &lt;- function(dds, gene) {\n  \n  # returnData to get normalized counts for each sample for a gene\n  d &lt;- plotCounts(dds, gene=gene, intgroup=\"condition\", returnData=TRUE)\n  # Keep the order TN then cold7\n  d$condition &lt;- factor(d$condition, levels = c(\"TN\", \"cold7\"))\n  \n  # Plot the normalized counts for each sample\n  p &lt;- ggplot(d, aes(x = condition, \n                     y = count, \n                     color = condition)) + \n    geom_point(position=position_jitter(w = 0.1, h = 0)) +\n    theme_bw() + NoLegend() +\n    ggtitle(gene)\n  \n  return(p)\n}\n\n\nplot_list &lt;- list()\nfor (gene in genes) {\n  plot_list[[gene]] &lt;- plot_pb_count(dds, gene)\n}\n\nplot_grid(plotlist=plot_list)\n\n\n\n\nFinally, it is also a good exercise to evaluate the gene expression at a single-cell level. The results we have been visualizing so far represent the sample averages of gene expression across all VSM cells in each sample. Therefore it is prudent to go back to the cellular level to see what these same results look like for each individual cell. To do so, we will make use of our original seurat object seurat_vsm.\nWe see that generally the trends are consistent with pseudobulk expression scatterplots, but in some cases the change is not as proncounced.\n\nDefaultAssay(seurat_vsm) &lt;- \"RNA\"\nIdents(seurat_vsm) &lt;- \"condition\"\nVlnPlot(seurat_vsm, genes, idents=c(\"cold7\", \"TN\"))\n\n\n\n\nIn the next lesson, we will continue with additional visualizations for the DESeq2 results while comparing and contrasting with results from the FindMarkers() analysis."
  },
  {
    "objectID": "lessons/00_counts_to_clusters_overview.html",
    "href": "lessons/00_counts_to_clusters_overview.html",
    "title": "Single-cell RNA-seq: From Counts to Clusters",
    "section": "",
    "text": "Approximate time: 20 minutes"
  },
  {
    "objectID": "lessons/00_counts_to_clusters_overview.html#learning-objectives",
    "href": "lessons/00_counts_to_clusters_overview.html#learning-objectives",
    "title": "Single-cell RNA-seq: From Counts to Clusters",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nDescribe the workflow for single-cell RNA-seq analysis starting from a count matrix through to annotated celltypes"
  },
  {
    "objectID": "lessons/00_counts_to_clusters_overview.html#filtering-data",
    "href": "lessons/00_counts_to_clusters_overview.html#filtering-data",
    "title": "Single-cell RNA-seq: From Counts to Clusters",
    "section": "Filtering data",
    "text": "Filtering data\nThe first step is to take the raw count data and use various metrics to identify true cells that are of high quality, so that when we cluster our cells it is easier to identify distinct cell type populations. Visualizing metrics with plots allows us to evaluate all samples within a dataset and isolate any problematic samples. Additionally, we can more easily decide on suitable thresholds for cell-level filtering. We want to be able to keep as many high quality cells as possible without removing biologically relevant cell types. Gene-level filtering is also applied at this stage."
  },
  {
    "objectID": "lessons/00_counts_to_clusters_overview.html#clustering-workflow",
    "href": "lessons/00_counts_to_clusters_overview.html#clustering-workflow",
    "title": "Single-cell RNA-seq: From Counts to Clusters",
    "section": "Clustering workflow",
    "text": "Clustering workflow\nFor something to be informative, it needs to exhibit variation, but not all variation is informative. The goal of our clustering analysis is to keep the major sources of variation in our dataset that should define our cell types, while restricting the variation due to uninteresting sources of variation (sequencing depth, cell cycle differences, mitochondrial expression, batch effects, etc.). Then, to determine the cell types present, we will perform a clustering analysis using the most variable genes to define the major sources of variation in the dataset.\nThe workflow for this analysis is adapted from the following sources:\n\nSatija Lab: Seurat v3 Guided Integration Tutorial\nPaul Hoffman: Cell-Cycle Scoring and Regression\n\nTo identify clusters, the following steps are performed:\n\n1. Explore sources of unwanted variation\nThe first step in the workflow is to see if our data contains any unwanted variability. The most common biological effect that is evaluated in single-cell RNA-seq data is the effect of cell cycle on the transcriptome. Another known biological effect is mitochondrial gene expression, which is interpreted as an indication of cell stress. This step of the workflow involves exploring our data to identify which covariates we would like to regress out.\n\n\n\n2. Normalization and regressing out sources of unwanted variation\nNormalization is required to scale the raw count data to obtain correct relative gene expression abundances between cells. The sctransform function implements an advanced normalization and variance stabilization of the data. The sctransform function also regresses out sources of unwanted variation in our data. In the previous step, we had identified these sources of variability, and here we specify what those covariates are.\n\nImage credit: Hafemeister C and Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genom Biology 2019 https://doi.org/10.1101/576827\n\n\n3. Integration\nOften with single cell RNA-seq we are working with multiple samples which correspond to different sample groups, multiple experiments or different modalities. If we want to ultimately compare celltype expression between groups it is recommended to integrate the data. Integration is a powerful method that uses these shared sources of greatest variation to identify shared sub-populations across conditions or datasets (Stuart and Butler et al. (2018)). There are several steps involved in performing intergration in Seurat. Once complete, we use visualization methods to ensure a good integration before we proceed to cluster cells.\n\n\n\n\n\n\n\nNote\n\n\n\nIntegration is optional. We recommend going through the workflow without integration to decide whether or not it is necessary for your data.\n\n\n\n\n4. Clustering cells\nClusters of cells are obtained by grouping cells based on the similarity of their gene expression profiles. Expression profile similarity is determined via distance metrics, which often take dimensionality‐reduced representations as input. Seurat assigns cells to clusters based on their PCA scores derived from the expression of the integrated most variable genes.\n\n\n\n5. Cluster quality evaluation\nThe clusters identified in our data represent groups of cells that presumably belong to a similar cell type. Before we can confirm the celltype of a group of member cells, the following steps are taken:\n\na. Check to see that clusters are not influenced by sources of uninteresting variation.\nb. Check to see whether the major principal components are driving the different clusters.\nc. Explore the cell type identities by looking at the expression for known markers across the clusters."
  },
  {
    "objectID": "lessons/00_counts_to_clusters_overview.html#marker-identification-and-celltype-assignment",
    "href": "lessons/00_counts_to_clusters_overview.html#marker-identification-and-celltype-assignment",
    "title": "Single-cell RNA-seq: From Counts to Clusters",
    "section": "Marker Identification and Celltype Assignment",
    "text": "Marker Identification and Celltype Assignment\nOften the known marker expression evaluation gives us some hints as to which celltype is represented within a cluster, but sometimes it is not so obvious. In situations where there is uncertainty of the cell type assignment it is good practice to check which genes exhibit a high expression profile among cells (i.e FindMarkers). The list of genes can provide insight on celltype and/or can be the impetus for removal of a group of cells. After this step we hope to obtain a fully annotated dataset that we can move forward with for downstream analysis."
  },
  {
    "objectID": "lessons/01b_gen_seurat_object.html",
    "href": "lessons/01b_gen_seurat_object.html",
    "title": "Sample pre-processing",
    "section": "",
    "text": "Approximate time: 15 minutes"
  },
  {
    "objectID": "lessons/01b_gen_seurat_object.html#learning-objectives",
    "href": "lessons/01b_gen_seurat_object.html#learning-objectives",
    "title": "Sample pre-processing",
    "section": "Learning Objectives",
    "text": "Learning Objectives\n\nUnderstand the steps taken to generate the Seurat object used as input for the workshop."
  },
  {
    "objectID": "lessons/01b_gen_seurat_object.html#sample-data",
    "href": "lessons/01b_gen_seurat_object.html#sample-data",
    "title": "Sample pre-processing",
    "section": "Sample data",
    "text": "Sample data\nFor this workshop, we will be working with a single-cell RNA-seq dataset from Tseng et al, 2021. The data is available on GEO GSE160585. The files we will need to create the fully processed Seurat object include:\n\nMetadata csv file\nCounts matrix\nList of features (genes)\nList of cell barcodes\n\nWe have an entire workshop of materials that go through the whole process step-by-step on how to generate a similarly fully annotated, filtered dataset from single-cell RNA-seq data. In this lesson we provide mostly code, so you can reproduce the object yourself. If you want an in-depth explanation of each step we encourage you to peruse the materials linked above."
  },
  {
    "objectID": "lessons/01b_gen_seurat_object.html#pre-processing-steps",
    "href": "lessons/01b_gen_seurat_object.html#pre-processing-steps",
    "title": "Sample pre-processing",
    "section": "Pre-processing steps",
    "text": "Pre-processing steps\n\nDownload and unzip the dataset from GEO using bash:\n\n\n#!/bin/bash\n\n# Create data directory to store downloaded files\nmkdir -p data/filtered_counts\n\n# Metadata csv file\nwget wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE160nnn/GSE160585/suppl/GSE160585%5Fmetadata%5Ffor%5Fpseudotime%5Fand%5Fpseudobulk%5FDGE.csv.gz -O data/meta.csv.gz\n\n# Features, barcodes, and counts matrix\nwget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE160nnn/GSE160585/suppl/GSE160585%5Ffiltered%5Fraw%5Fcounts%5Ffor%5Fpseudotime%5Fand%5Fpseudobulk%5FDGE.tar.gz -O data/filtered_counts.tar.gz\n\n# Unzip and decompress the files\ntar -xvf data/filtered_counts.tar.gz -C data/filtered_counts\ngunzip data/meta.csv.gz\n\n\nData wrangling of the metadata\n\n\nlibrary(tidyverse)\nmeta &lt;- read.csv(\"data/meta.csv\", row.names=1)\n\n# Celltype IDs have are formatted like: \n# {celltype}_{cluster}\n# Removing the underscore\nmeta$celltype &lt;- sub(\"_.*\", \"\", meta$cluster_id)\nmeta &lt;- select(meta, -c(cluster_id))\n\n# The following columns in the metadata have duplicate values:\n# - nCount_RNA = nUMI\n# - nFeature_RNA = nGene\nmeta &lt;- select(meta, -c(nUMI, nGene))\n\n# Rename columns for more clarity\nmeta &lt;- meta %&gt;%\n    rename(c(\"orig.ident\"=\"sample\", \"sample\"=\"condition\"))\n\n\n# Removing cluster resolutions that will not be used\ncols &lt;- c(\n    \"integrated_snn_res.0.1\",\n    \"integrated_snn_res.0.4\",\n    \"integrated_snn_res.0.6\",\n    \"integrated_snn_res.0.8\",\n    \"integrated_snn_res.1\",\n    # \"integrated_snn_res.1.2\",\n    \"integrated_snn_res.1.4\",\n    \"integrated_snn_res.1.8\",\n    \"seurat_clusters\"\n)\n\nmeta &lt;- meta %&gt;% select(-c(cols))\n\n# Store clusters IDs as factors\nmeta$seurat_clusters &lt;- meta$integrated_snn_res.1.2\nsorted_cluster &lt;- sort(as.integer(unique(meta$seurat_clusters)))\nmeta$seurat_clusters &lt;- factor(meta$seurat_clusters, levels=sorted_cluster)\n\n\nGenerate Seurat object using downloaded files as input\n\n\nlibrary(Seurat)\nlibrary(Matrix)\nset.seed(1454944673L) # Using the same seed used in the paper\n\n# Load metadata, barcodes, features, and matrix into R\nbarcodes &lt;- read.csv(\"data/filtered_counts/barcodes_filtered_raw_counts_for_pseudotime_and_pseudobulk_DGE.tsv\", header=FALSE)\nfeatures &lt;- read.csv(\"data/filtered_counts/genes_filtered_raw_counts_for_pseudotime_and_pseudobulk_DGE.tsv\", header=FALSE)\ncounts &lt;- readMM(\"data/filtered_counts/filtered_raw_counts_for_pseudotime_and_pseudobulk_DGE.mtx\")\n\n# Add gene and cell barcode information to count matrix\nrow.names(counts) &lt;- features$V1\ncolnames(counts) &lt;- barcodes$V1\n\n# Create seurat object\nseurat &lt;- CreateSeuratObject(\n    counts, \n    project = \"GSE160585\", \n    assay = \"RNA\", \n    meta.data = meta)\n\n\n\n\n\n\n\nNote\n\n\n\nIn the next few steps we have provided the code to process the Seurat object. The parameters for each step were chosen based upon the descriptions provided in the Methods section of the paper.\n\n\n\nLog-normalization and highly variable genes\n\n\n# Log normalization\nseurat &lt;- NormalizeData(seurat)\n\n# Identify the most variable genes\nseurat &lt;- FindVariableFeatures(seurat, \n                     selection.method = \"vst\",\n                     nfeatures = 3000, \n                     verbose = FALSE)\n\n\nSCTransform and regress out cell cycle scores\n\n\n# Split seurat object by sample\nsplit_seurat &lt;- SplitObject(seurat, split.by = \"condition\")\n\n# Allow R to use more memory\noptions(future.globals.maxSize = 4000 * 1024^2)\n\n# Run SCTranform on each sample individually\nfor (i in 1:length(split_seurat)) {\n    # Regress out cell cycle scores\n    split_seurat[[i]] &lt;- SCTransform(split_seurat[[i]], \n                                    vars.to.regress = c(\"S.Score\", \"G2M.Score\"), \n                                    vst.flavor = \"v2\",\n                                    variable.features.n = 3000)\n}\n\n\nCCA integration\n\n\n# Select the most variable features to use for integration\ninteg_features &lt;- SelectIntegrationFeatures(object.list = split_seurat, \n                                            nfeatures = 3000)\n# Prepare the SCT list object for integration\nsplit_seurat &lt;- PrepSCTIntegration(object.list = split_seurat,\n                                    anchor.features = integ_features)\n# Find best buddies - can take a while to run\ninteg_anchors &lt;- FindIntegrationAnchors(object.list = split_seurat,\n                                        normalization.method = \"SCT\",\n                                        anchor.features = integ_features)\n# Integrate across conditions\nseurat_integrated &lt;- IntegrateData(anchorset = integ_anchors, \n                                    normalization.method = \"SCT\")\n\n# Rejoin the layers in the RNA assay that we split earlier\nseurat_integrated[[\"RNA\"]] &lt;- JoinLayers(seurat_integrated[[\"RNA\"]])\n\n\nPCA, nearest neighbors, UMAP\n\n\nseurat_integrated &lt;- RunPCA(seurat_integrated, verbose = FALSE)\nseurat_integrated &lt;- RunUMAP(seurat_integrated, dims = 1:50)\nseurat_integrated &lt;- FindNeighbors(seurat_integrated, dims = 1:50)\n\n\nSave seurat object\n\n\nIdents(seurat_integrated) &lt;- \"condition\"\nDefaultAssay(seurat_integrated) &lt;- \"RNA\"\n\nsaveRDS(seurat_integrated, \"data/BAT_GSE160585.rds\")"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html",
    "title": "DE analysis using FindMarkers",
    "section": "",
    "text": "Approximate time: 75 minutes"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#learning-objectives",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#learning-objectives",
    "title": "DE analysis using FindMarkers",
    "section": "Learning Objectives:",
    "text": "Learning Objectives:\n\nEvaluate differential gene expression between conditions using a Wilcoxon rank sum test\nCreate visualizations for differentially expressed genes\nDiscuss other statistical tests for differential expression analysis"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#differential-expression-between-conditions-using-findmarkers",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#differential-expression-between-conditions-using-findmarkers",
    "title": "DE analysis using FindMarkers",
    "section": "Differential expression between conditions using FindMarkers()",
    "text": "Differential expression between conditions using FindMarkers()\nIn our current UMAP, we have merged samples across the different conditions and used integration to align cells of the same celltype across samples. Now, what if we were interested in a particular celltype and understanding how gene expression changes across the different conditions?\nThe FindMarkers() function in the Seurat package is used to perform differential expression analysis between groups of cells. We provide arguments to specify ident.1 and ident.2 the two groups of cells we are interested in comparing. This function is commonly used at the celltype annotation step, but can also be used to calculate differentially expressed genes between experimental conditions.\n\n\n\nWe can use this same function to compare two groups of cells which represent different conditions by modifying the ident values provided. The FindMarkers() function has several important arguments we can modify when running it. To view what these parameters are, we can access the help page on this function:\n\n?FindMarkers\n\nBelow we have described in more detail what each of these arguments mean :\n\nlogfc.threshold: The minimum log2 fold change for average expression of gene in group relative to the average expression in all other groups combined. Default is 0.25.\nmin.diff.pct: The minimum percent difference between the percent of cells expressing the gene in the group and the percent of cells expressing gene in all other groups combined.\nmin.pct: Only test genes that are detected in a minimum fraction of cells in either of the two populations. Meant to speed up the function by not testing genes that are very infrequently expressed. Default is 0.1.\nident.1: This function only evaluates one group at a time; here you would specify the group of interest. These values must be set in the Idents().\nident.2: Here you would specify the group you want to compare ident.1 against."
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#setting-up",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#setting-up",
    "title": "DE analysis using FindMarkers",
    "section": "Setting up",
    "text": "Setting up\nOpen up a new Rscript file, and start with some comments to indicate what this file is going to contain:\n\n# Single-cell RNA-seq DE analysis - FindMarkers\n\nSave the Rscript as findMarkers.R.\n\nLoad libraries\nNow let’s load the required libraries for this analysis:\n\n# Load libraries\nlibrary(Seurat)\nlibrary(tidyverse)\nlibrary(EnhancedVolcano)"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#findmarkers",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#findmarkers",
    "title": "DE analysis using FindMarkers",
    "section": "FindMarkers()",
    "text": "FindMarkers()\nTo use the function to look for DE genes between conditions, there are two things we need to do:\n\nSubset the Seurat object to our celltype of interest\nSet our active Idents to be the metadata column which specifies what condition each cell is\n\nIn our example we are focusing on vascular smooth muscle (VSM) cells. The comparison we will be making is TN vs. cold7.\n\n# Subset the object\nseurat_vsm &lt;- subset(seurat, subset = (celltype == \"VSM\"))\n\n# Set the idents\nIdents(seurat_vsm) &lt;- \"condition\"\nseurat_vsm\n\nAn object of class Seurat \n40338 features across 12372 samples within 3 assays \nActive assay: RNA (19771 features, 3000 variable features)\n 2 layers present: data, counts\n 2 other assays present: SCT, integrated\n 2 dimensional reductions calculated: pca, umap\n\n\nBefore we make our comparisons we will explicitly set our default assay, we want to use the normalized data, not the integrated data.\n\n# Set default assay\nDefaultAssay(seurat_vsm) &lt;- \"RNA\"\n\nThe default assay should have already been RNA, but we encourage you to run this line of code above to be absolutely sure in case the active slot was changed somewhere upstream in your analysis.\n\n\n\n\n\n\nWhy don’t we use SCT normalized data?\n\n\n\nNote that the raw and normalized counts are stored in the counts and data slots of RNA assay, respectively. By default, the functions for finding markers will use normalized data if RNA is the DefaultAssay. The number of features in the RNA assay corresponds to all genes in our dataset.\nNow if we consider the SCT assay, functions for finding markers would use the scale.data slot which is the pearson residuals that come out of regularized NB regression. Differential expression on these values can be difficult interpret. Additionally, only the variable features are represented in this assay and so we may not have data for some of our marker genes.\n\n\nNow we can run FindMarkers():\n\n# Determine differentiating markers for TN and cold7\ndge_vsm &lt;- FindMarkers(seurat_vsm,\n                       ident.1=\"cold7\",\n                       ident.2=\"TN\"\n                       )\n\nNow let’s take a quick look at the results:\n\n# View results \ndge_vsm %&gt;% head()\n\n                p_val avg_log2FC pct.1 pct.2     p_val_adj\nGm42418 4.492261e-223  1.8013603 0.999 0.986 8.881650e-219\nUbb     1.801612e-207 -0.8274973 0.982 0.999 3.561968e-203\nH3f3b   6.044423e-198 -0.9395566 0.975 0.998 1.195043e-193\nNr4a2   9.607598e-193 -2.1841673 0.503 0.855 1.899518e-188\nRpl21   2.319987e-190 -0.6377144 0.967 0.998 4.586847e-186\nRpl9    1.249444e-187 -0.6824496 0.954 0.999 2.470276e-183\n\n\nThe output from the FindMarkers() function is a matrix containing a ranked list of differentially expressed genes listed by gene ID and associated statistics. We describe some of these columns below:\n\ngene: The gene symbol\np_val: The p-value not adjusted for multiple test corrections\navg_logFC: The average log-fold change between sample groups. Positive values indicate that the gene is more highly expressed ident.1.\n\npct.1: The percentage of cells where the gene is detected in ident.1 (cold7)\n\npct.2: The percentage of cells where the gene is detected on average in ident.2 (TN)\np_val_adj: The adjusted p-value, based on Bonferroni correction using all genes in the dataset, used to determine significance\n\n\n\n\n\n\n\nNote\n\n\n\nThese tests treat each cell as an independent replicate and ignore inherent correlations between cells originating from the same sample. This results in highly inflated p-values for each gene. Studies have been shown to find a large number of false positive associations with these results.\n\n\nWhen looking at the output, we suggest looking for markers with large differences in expression between pct.1 and pct.2 and larger fold changes. For instance if pct.1 = 0.90 and pct.2 = 0.80, it may not be as exciting of a marker. However, if pct.2 = 0.1 instead, the bigger difference would be more convincing. Also of interest is whether the majority of cells expressing the gene are in the group of interest. If pct.1 is low, such as 0.3, it may not be as interesting. Both of these are also possible parameters to include when running the function, as described above.\nThis is a great spot to pause and save your results!\n\nwrite.csv(dge_vsm, \"../results/findmarkers_vsm_cold7_vs_TN.csv\")"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#significant-genes",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#significant-genes",
    "title": "DE analysis using FindMarkers",
    "section": "Significant genes",
    "text": "Significant genes\nWe want to subset our results to show just our significant genes so we can begin visualizing and analyzing the results. To do this, we filter out rows based upon the p_val_adj column and subsetting only genes that meet our multiple testing-corrected significance threshold of 0.05.\n\n# Subset significant genes\ndge_vsm_sig &lt;- dge_vsm %&gt;% subset(p_val_adj &lt; 0.05)\ndge_vsm_sig %&gt;% head()\n\n                p_val avg_log2FC pct.1 pct.2     p_val_adj\nGm42418 4.492261e-223  1.8013603 0.999 0.986 8.881650e-219\nUbb     1.801612e-207 -0.8274973 0.982 0.999 3.561968e-203\nH3f3b   6.044423e-198 -0.9395566 0.975 0.998 1.195043e-193\nNr4a2   9.607598e-193 -2.1841673 0.503 0.855 1.899518e-188\nRpl21   2.319987e-190 -0.6377144 0.967 0.998 4.586847e-186\nRpl9    1.249444e-187 -0.6824496 0.954 0.999 2.470276e-183\n\n\n\nVolcano plot\nTo get a first look at the genes that are retained, we can generated a volcano plot using the EnhancedVolcano() function. This is a visualization that allows us to quickly see trends in the significant genes. The x-axis here represents the average log2-fold change value, showing the degree of difference between the two conditions. On the y-axis, we see our p_val_adj column represented after a negative log10 transformation is applied to better see the spread of the adjusted p-values.\nVolcano plots provide a great overview of which genes are up-regulated (positive on the x-axis) or down-regulated (negative on the x-axis).\n\n# Volcano plot\np_fm &lt;- EnhancedVolcano(dge_vsm_sig,\n        row.names(dge_vsm_sig),\n        x=\"avg_log2FC\",\n        y=\"p_val_adj\",\n       title=\"FindMarkers VSM cells\",\n       subtitle=\"TN vs cold7\")\n\np_fm\n\n\n\n\n\n\nViolin plots\nWhile looking at the overall trends in the data is a great starting point, we can also start looking at genes that have large differences between TN and cold7. To do this, we can take a look at the top 6 genes with the smallest p-values. We additionally disregard the ribsomal genes in this visualization step.\n\n# Get the gene names and get the first 6 values\n# Ignore ribosomal genes\ngenes &lt;- dge_vsm_sig %&gt;%\n  rownames_to_column(var=\"gene\") %&gt;%\n  filter(!str_detect(gene, \"Rpl|Rps\")) %&gt;% \n  head(6)\ngenes &lt;- genes$gene\ngenes\n\n[1] \"Gm42418\" \"Ubb\"     \"H3f3b\"   \"Nr4a2\"   \"Cebpb\"   \"Fau\"    \n\n\nWith these genes selected, we can now being to visualize the distribution of expression across our two conditions using the VlnPlot() function.\n\n# Set Idents and draw Violin plots for top 6 genes\nIdents(seurat_vsm) &lt;- \"condition\"\nVlnPlot(seurat_vsm, genes, ncol=3, idents=c(\"TN\", \"cold7\"))\n\n\n\n\n\n\nUMAP plots\nWhen comparing two different conditions, we recommend creating a UMAP that clearly shows where the cells exist for each condition. To do so, we first need to get the UMAP coordinates for every cell of interest. When creating the scatterplot, the first thing we do is put a layer of light gray points that show the entire dataset to understand where all the cells fall. Then, we take the UMAP coordinates of the condition (TN or cold7 in our example) and plot those on top with a color to clearly indicate where those cells are located.\n\n\n\n\n\n\nNote\n\n\n\nThis sometimes works better on the non-integrated data, so you observe a true separation of cells by condition.\n\n\n\n# Grab the umap coordinates and condition information for each cell\ndf &lt;- FetchData(seurat_vsm, c(\"umap_1\", \"umap_2\", \"condition\"))\ndf_tn &lt;- df %&gt;% subset(condition == \"TN\")\ndf_cold7 &lt;- df %&gt;% subset(condition == \"cold7\")\n\n# Scatterplot of TN cells\np_tn &lt;- ggplot() +\n  geom_point(data=df, aes(x=umap_1, y=umap_2), color=\"lightgray\", alpha=0.5, size = 0.1) +\n  geom_point(data=df_tn, aes(x=umap_1, y=umap_2), color=\"#F8766D\", size = 0.1) +\n  theme_classic() +\n  ggtitle(\"VSM: TN cells\")\n\n# Scatterplot of cold7 cells\np_cold7 &lt;- ggplot() +\n  geom_point(data=df, aes(x=umap_1, y=umap_2), color=\"lightgray\", alpha=0.5, size = 0.1) +\n  geom_point(data=df_cold7, aes(x=umap_1, y=umap_2), color=\"#00B8E7\", size = 0.1) +\n  theme_classic() +\n  ggtitle(\"VSM: cold7 cells\")\n\n# TN and cold7 UMAPs side by side\np_tn + p_cold7\n\n\n\n\nThis allows us to better understand our results when we look at any follow-up information on our UMAP. For example, we can begin to look at the distribution of gene expression for each of the top 6 genes with a better understanding of where the cells for each condition lie:\n\nFeaturePlot(seurat_vsm, genes, ncol=3)"
  },
  {
    "objectID": "lessons/02_DEanalysis_using_FindMarkers.html#other-statistical-tests",
    "href": "lessons/02_DEanalysis_using_FindMarkers.html#other-statistical-tests",
    "title": "DE analysis using FindMarkers",
    "section": "Other statistical tests",
    "text": "Other statistical tests\nWhen we looked at the extra explanations for the FindMarkers() function, there was a parameter called test.use. By default, the method for calculating differentially expressed genes will be a Wilcoxon Rank Sum Test. This is a fairly simple statistical approach, and there a multitude of different algorithms that can be specified. These other options are documented on the FindMarkers() documentation page. For this workshop we want to highlight a few of these methods:\n\nWilcoxon Rank Sum Test\n\nOften described as the non-parametric version of the two-sample t-test.\nBeneficial because it can reduce the impact of outliers, which can skew the results of parametric testing.\nIt ranks the data and compares the sum of ranks within each group, to identify significant differences.\n\n\n\nDESeq2\n\nIdentifies differentially expressed genes between two groups of cells based on a model using DESeq2 which uses a negative binomial distribution (Love et al., 2014). More information on DESeq2 will be provided in an upcoming lesson in this workshop.\nThis test option does not support pre-filtering of genes based on average difference (or percent detection rate) between cell groups. However, genes may be pre-filtered based on their minimum detection rate (min.pct) across both cell groups.\n\n\n\n\n\n\n\nNote\n\n\n\nThe creators of the Seurat package no longer recommend using the FindMarkers() implementation of DESeq2.\n\n\n\n\nMAST\n\nImplements an approach that accounts for the stochastic dropout and characteristic bimodal expression distributions in which expression is either strongly non-zero or non-detectable.\n\nA two-part, generalized linear model for such bimodal data that parameterizes both of these features\n\n\nAlso allows for estimation and control of the “cellular detection rate” (CDR) while simultaneously estimating treatment effects. This addresses the fact that cells scale transcript copy number with cell volume.\nPermits the analysis of complex experiments, such as repeated single-cell measurements under various treatments or longitudinal sampling of single cells from multiple subjects with a variety of background characteristics (e.g., sex, age), because it can easily be extended to accommodate random effects.\n\n\nNOTE: Instead of using the FindMarkers() implementation, we recommend directly using the MAST algorithm from the package itself for the best results.\nIf you are interested in exploring code to run MAST on this dataset directly using the package, please see the script at the link below. We recommend including the sample in the model to improve results by taking into account biological variability. Please note that this is a computationally intensive calculation and may take a long time to run.\n\n\nClick here for code to run MAST on this dataset side-by-side\n\nNote that this R code below uses the MAST library. In order to run this you will need to first install the required packagea and then &gt; load the libraries.\n\nlibrary(Seurat)\nlibrary(dplyr)\nlibrary(SingleCellExperiment)\nlibrary(MAST)\n\n# Seurat to SingleCellExperiment\nDefaultAssay(seurat_vsm) &lt;- \"RNA\"\nsce &lt;- as.SingleCellExperiment(seurat_vsm)\n# Apply log transformation\nassay(sce, \"logcounts\") &lt;- log2(counts(sce) + 1)\n\n# Create new sce object (with only 'logcounts' matrix)\nsce_1 &lt;- SingleCellExperiment(assays = list(logcounts = assay(sce, \"logcounts\")))\ncolData(sce_1) &lt;- colData(sce)\n\n# Change to SingleCellAssay\nsca &lt;- SceToSingleCellAssay(sce_1)\n\n# Calculate number of genes expressed per cell and scale the value\ncdr2 &lt;- colSums(SummarizedExperiment::assay(sca) &gt; 0)\ncolData(sca)$cngeneson &lt;- scale(cdr2)\n\n# Takes a long time to calculate!\n# Here our model includes:\n\t# The number of genes expressed (ngeneson)\n\t# Experimental condition (condition)\n\t# Sample as a random variable ((1 | sample))\n\nzlmCond &lt;- zlm(~condition + cngeneson + (1 | sample), \n               sca, method=\"glmer\", ebayes=FALSE)\n\n# Only test the condition coefficient.\nsummaryCond &lt;- summary(zlmCond, doLRT='conditionTN') \n\n# Some data wranging of the results\nsummaryDt &lt;- summaryCond$datatable\nfcHurdle &lt;- merge(summaryDt[contrast=='conditionTN' & component=='H',.(primerid, `Pr(&gt;Chisq)`)], #hurdle P values\n                 summaryDt[contrast=='conditionTN' & component=='logFC', \n                           .(primerid, coef, ci.hi, ci.lo)], by='primerid') #logFC coefficients\n\nfcHurdle[,fdr:=p.adjust(`Pr(&gt;Chisq)`, 'fdr')]"
  },
  {
    "objectID": "lessons/schedule.html",
    "href": "lessons/schedule.html",
    "title": "",
    "section": "",
    "text": "Code"
  },
  {
    "objectID": "lessons/schedule.html#pre-reading",
    "href": "lessons/schedule.html#pre-reading",
    "title": "",
    "section": "Pre-reading",
    "text": "Pre-reading\n\nIntroduction to scRNA-seq\nscRNA-seq: From sequence reads to count matrix\nscRNA-seq: From counts to clusters\nDownload this project"
  },
  {
    "objectID": "lessons/schedule.html#day-1",
    "href": "lessons/schedule.html#day-1",
    "title": "",
    "section": "Day 1",
    "text": "Day 1\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:30 - 09:45\nWorkshop introduction\nWill\n\n\n09:45 - 10:15\nPre-reading review and Q&A\nAll\n\n\n10:15 - 10:25\nBreak\n\n\n\n10:25 - 11:00\nProject setup and data exploration\nWill\n\n\n11:00 - 11:50\nDifferential expression analysis using FindMarkers()\nNoor\n\n\n11:50 - 12:00\nOverview of self-learning materials and homework submission\nWill\n\n\n\n\nBefore the next class:\nI. Please study the contents and work through all the code within the following lessons:\n\nAggregating counts by celltype using pseudobulk approach\n\n\nClick here for a preview of this lesson\n\n Forming pseudobulk samples is important to perform accurate differential expression analysis. Treating each cell as an independent replicate leads to underestimation of the variance and misleadingly small p-values. Working on the level of pseudobulk ensures reliable statistical tests because the samples correspond to the actual units of replication. In this lesson you will: - Aggregate counts for a given celltype - Demonstrate an efficent way to aggregate counts for multiple celltypes - Use the aggregated counts to create a DESeq2 object for downstream analysis \n\nDE analysis of pseudobulk data using DESeq2\n\n\nClick here for a preview of this lesson\n\n The next step is to take the DESeq2 object and run through the analysis workflow to identify differentially expressed genes. In this lesson you will: - Perform sample level QC\n- Evaluate gene-wise dispersions to evalute model fit - Extract results and understand the statistics generated\n\n\n\nSubmit your work:\n\n\nEach lesson above contains exercises; please go through each of them.\nSubmit your answers to the exercises using this Google form on the day before the next class.\n\n\n\nQuestions?\n\nIf you get stuck due to an error while running code in the lesson, email us"
  },
  {
    "objectID": "lessons/schedule.html#day-2",
    "href": "lessons/schedule.html#day-2",
    "title": "",
    "section": "Day 2",
    "text": "Day 2\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:30 - 10:00\nSelf-learning lessons discussion\nAll\n\n\n10:00 - 10:40\nVisualization of differentially expressed genes\nWill\n\n\n10:40 - 10:50\nBreak\n\n\n\n10:50 - 12:00\nComparison of results from different DE approaches\nNoor\n\n\n\n\nBefore the next class:\nI. Please study the contents and work through all the code within the following lessons: 1. Functional Analysis\n\n\nClick here for a preview of this lesson\n\nNow that we have significant genes, let’s gain some biological insight In this lesson, we will: - Discuss approaches for functional analysis - Use clusterProfiler to run over-representation analsyis and visualize results - Use clusterProfiler to run GSEA \n\n\nSubmit your work:\n\n\nEach lesson above contains exercises; please go through each of them.\nSubmit your answers to the exercises using this Google form on the day before the next class.\n\n\n\nQuestions?\n\nIf you get stuck due to an error while running code in the lesson, email us"
  },
  {
    "objectID": "lessons/schedule.html#day-3",
    "href": "lessons/schedule.html#day-3",
    "title": "",
    "section": "Day 3",
    "text": "Day 3\n\n\n\nTime\nTopic\nInstructor\n\n\n\n\n09:30 - 10:15\nSelf-learning lessons discussion\nAll\n\n\n10:15 - 11:15\nMethods for Differental Abundance\nNoor\n\n\n11:15 - 11:20\nBreak\n\n\n\n11:25 - 11:45\nDiscussion and Q&A\nAll\n\n\n11:45 - 12:00\nWrap-up\nWill"
  },
  {
    "objectID": "lessons/schedule.html#answer-keys",
    "href": "lessons/schedule.html#answer-keys",
    "title": "",
    "section": "Answer Keys",
    "text": "Answer Keys\n\nDay 1 exercises\nDay 2 exercises"
  },
  {
    "objectID": "lessons/schedule.html#resources",
    "href": "lessons/schedule.html#resources",
    "title": "",
    "section": "Resources",
    "text": "Resources"
  }
]